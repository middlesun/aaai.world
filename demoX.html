<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal HTML Previewer - Auto-Discovery</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
        }
        
        .gradient-text {
            background: linear-gradient(90deg, #3b82f6 0%, #8b5cf6 50%, #ec4899 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .style-card {
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .style-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
        }
        
        .style-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }
        
        .style-card:hover::before {
            transform: translateX(100%);
        }
        
        .thumbnail {
            position: relative;
            overflow: hidden;
            background: #f8fafc;
        }
        
        .thumbnail iframe {
            width: 100%;
            height: 100%;
            border: none;
            transform: scale(0.3);
            transform-origin: top left;
            width: 333.33%;
            height: 333.33%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            overflow: hidden;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* Internet Explorer 10+ */
        }
        
        .thumbnail iframe::-webkit-scrollbar {
            display: none; /* WebKit */
        }
        
        .thumbnail iframe.loaded {
            opacity: 1;
        }
        
        .thumbnail-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6b7280;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .thumbnail-error {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: #6b7280;
        }
        
        .thumbnail::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.1);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .style-card:hover .thumbnail::after {
            opacity: 1;
        }
        
        .thumbnail-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.7));
            color: white;
            padding: 8px;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            font-size: 0.75rem;
        }
        
        .style-card:hover .thumbnail-overlay {
            transform: translateY(0);
        }
        
        .tag {
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.2);
            transition: all 0.2s;
        }
        
        .tag:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: scale(1.05);
        }
        
        .tag.external-deps {
            background: rgba(251, 146, 60, 0.1);
            color: #ea580c;
            border: 1px solid rgba(251, 146, 60, 0.2);
        }
        
        .tag.external-deps:hover {
            background: rgba(251, 146, 60, 0.2);
        }
        
        .tag.real-path {
            background: rgba(16, 185, 129, 0.1);
            color: #059669;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }
        
        .tag.real-path:hover {
            background: rgba(16, 185, 129, 0.2);
        }
        
        .tag.tracker-real-path {
            background: rgba(34, 197, 94, 0.1);
            color: #15803d;
            border: 1px solid rgba(34, 197, 94, 0.2);
            font-weight: 600;
            position: relative;
        }
        
        .tag.tracker-real-path:hover {
            background: rgba(34, 197, 94, 0.2);
            transform: scale(1.05);
        }
        
        .tag.tracker-real-path::before {
            content: 'üéØ';
            margin-right: 4px;
        }
        
        .tag.saved-absolute-path {
            background: rgba(147, 51, 234, 0.1);
            color: #7c2d92;
            border: 1px solid rgba(147, 51, 234, 0.2);
            font-weight: 600;
            position: relative;
        }
        
        .tag.saved-absolute-path:hover {
            background: rgba(147, 51, 234, 0.2);
            transform: scale(1.05);
        }
        
        .tag.saved-absolute-path::before {
            content: 'üíæ';
            margin-right: 4px;
        }
        
        .tag.tracker-network {
            background: rgba(6, 182, 212, 0.1);
            color: #0e7490;
            border: 1px solid rgba(6, 182, 212, 0.2);
            font-weight: 600;
        }
        
        .tag.tracker-network:hover {
            background: rgba(6, 182, 212, 0.2);
            transform: scale(1.05);
        }
        
        .tag.tracker-network::before {
            content: 'üï∏Ô∏è';
            margin-right: 4px;
        }
        
        .tag.remote-tracker {
            background: rgba(168, 85, 247, 0.1);
            color: #7c3aed;
            border: 1px solid rgba(168, 85, 247, 0.2);
            font-weight: 600;
        }
        
        .tag.remote-tracker:hover {
            background: rgba(168, 85, 247, 0.2);
            transform: scale(1.05);
        }
        
        .tag.remote-tracker::before {
            content: 'üì°';
            margin-right: 4px;
        }
        
        .tag.blob-url {
            background: rgba(139, 92, 246, 0.1);
            color: #7c3aed;
            border: 1px solid rgba(139, 92, 246, 0.2);
        }
        
        .tag.blob-url:hover {
            background: rgba(139, 92, 246, 0.2);
        }
        
        .tag.modern-api {
            background: rgba(14, 165, 233, 0.1);
            color: #0284c7;
            border: 1px solid rgba(14, 165, 233, 0.2);
        }
        
        .tag.modern-api:hover {
            background: rgba(14, 165, 233, 0.2);
        }
        
        .action-btn {
            position: absolute;
            right: 12px;
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
        }
        
        .action-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .action-btn i {
            font-size: 16px;
            color: #6b7280;
            transition: all 0.3s ease;
        }
        
        /* Favorite button styles */
        .favorite-btn {
            top: 12px;
        }
        
        .favorite-btn.favorited {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border-color: #ef4444;
        }
        
        .favorite-btn.favorited:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: scale(1.15);
        }
        
        .favorite-btn.favorited i {
            color: white;
        }
        
        /* Bookmark button styles */
        .bookmark-btn {
            top: 58px;
        }
        
        .bookmark-btn.bookmarked {
            background: linear-gradient(135deg, #10b981, #059669);
            border-color: #10b981;
        }
        
        .bookmark-btn.bookmarked:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: scale(1.15);
        }
        
        .bookmark-btn.bookmarked i {
            color: white;
        }
        
        /* Remove old positioning - will be set below with new layout */
        
        /* Action Button Layout (positioned from top) */
        /* Tag button styles */
        .tag-btn {
            top: 104px;
        }
        
        .tag-btn:hover {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
            border-color: #06b6d4;
        }
        
        .tag-btn:hover i {
            color: white;
        }
        
        /* Folder button styles */
        .folder-btn {
            top: 150px;
        }
        
        .folder-btn:hover {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            border-color: #8b5cf6;
        }
        
        .folder-btn:hover i {
            color: white;
        }
        
        /* Remove button styles */
        .remove-btn {
            top: 196px;
        }
        
        .remove-btn:hover {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border-color: #f59e0b;
        }
        
        .remove-btn:hover i {
            color: white;
        }
        
        /* Delete button styles */
        .delete-btn {
            top: 242px;
        }
        
        .delete-btn:hover {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border-color: #ef4444;
        }
        
        .delete-btn:hover i {
            color: white;
        }
        
        /* Selection checkbox styles */
        .selection-checkbox {
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 15;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 6px;
            padding: 6px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }
        
        .selection-checkbox:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #3b82f6;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .selection-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #3b82f6;
        }
        
        .style-card.selection-mode {
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .style-card.selection-mode.selected {
            border-color: #3b82f6;
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }
        
        .style-card.selection-mode .selection-checkbox {
            display: block !important;
            opacity: 1 !important;
            pointer-events: all !important;
        }
        
        .filter-btn {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .filter-btn.active {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }
        
        .search-container {
            position: relative;
        }
        
        .search-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, #3b82f6, #8b5cf6, #ec4899);
            border-radius: 12px;
            padding: 2px;
            z-index: -1;
        }
        
        .loading-skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .fade-in {
            animation: fadeIn 0.6s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .pulse-glow {
            animation: pulseGlow 2s infinite;
        }
        
        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.3); }
            50% { box-shadow: 0 0 30px rgba(59, 130, 246, 0.6); }
        }
        
        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            padding: 12px 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
        }
        
        .status-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .status-indicator.scanning {
            border-left: 4px solid #3b82f6;
        }
        
        .status-indicator.success {
            border-left: 4px solid #10b981;
        }
        
        .status-indicator.error {
            border-left: 4px solid #ef4444;
        }
        
        .file-info {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 8px 12px;
            margin-top: 8px;
            font-family: monospace;
            font-size: 11px;
            color: #6b7280;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .refresh-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .refresh-btn:hover {
            transform: scale(1.1) rotate(180deg);
            box-shadow: 0 12px 35px rgba(59, 130, 246, 0.5);
        }
        
        .no-results-illustration {
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 2rem;
            position: relative;
            overflow: hidden;
        }
        
        .no-results-illustration::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.5), transparent);
            transform: translateX(-100%);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
    </style>
</head>
<body class="min-h-screen py-8 px-4 sm:px-6 lg:px-8">
    <!-- Status Indicator -->
    <div id="statusIndicator" class="status-indicator">
        <i class="fas fa-spinner fa-spin text-blue-500"></i>
        <span id="statusText">Scanning directory...</span>
    </div>
    
    <!-- Refresh Button -->
    <div class="refresh-btn" onclick="refreshFiles()" title="Refresh Directory">
        <i class="fas fa-sync-alt text-xl"></i>
    </div>

    <div class="max-w-7xl mx-auto">
        <!-- Top Right Controls -->
        <div class="fixed top-4 right-4 z-50 flex gap-2">
            <button 
                id="clearDataBtn" 
                class="bg-gray-400 hover:bg-gray-500 text-white p-3 rounded-lg shadow-lg transition-all duration-300"
                title="Clear all saved data (favorites, sessions, preferences)"
            >
                <i class="fas fa-trash-alt text-lg"></i>
            </button>
            
            <button 
                id="bookmarkSettingsBtn" 
                class="bg-gray-400 hover:bg-gray-500 text-white p-3 rounded-lg shadow-lg transition-all duration-300"
                title="Change bookmark folder location"
            >
                <i class="fas fa-cog text-lg"></i>
            </button>
        </div>

        <!-- Header Section -->
        <div class="text-center mb-12">
            <h1 class="text-4xl md:text-6xl font-extrabold mb-6">
                <span class="gradient-text">Universal HTML Previewer</span>
                <span class="text-2xl md:text-3xl ml-4">üéØ</span>
            </h1>
            <p class="text-xl md:text-2xl text-gray-600 max-w-3xl mx-auto mb-4">
                <strong>Universal Directory Tracker</strong> - Works on ANY system (Windows/Mac/Linux) with REAL file:// URLs
            </p>
            <p class="text-sm text-gray-500 max-w-4xl mx-auto mb-8">
                üéØ <strong>Current Directory</strong> uses real <code>file://</code> URLs (Universal Tracker) ‚Ä¢ 
                üìÅ <strong>Add Folders</strong> permanently saves folder locations for easy file access (multiple folders supported) ‚Ä¢ 
                üîÑ <strong>Smart Scanning</strong> includes subdirectories and sorts by last modified ‚Ä¢ 
                üõ°Ô∏è <strong>Browser Security</strong> prevents real file paths for user-selected folders (this is normal)
            </p>
            <details class="max-w-4xl mx-auto mb-8 text-xs text-gray-500 cursor-pointer">
                <summary class="hover:text-gray-700">üîí Why can't we get real file paths even with user permission?</summary>
                <div class="mt-2 p-3 bg-gray-50 rounded border text-left">
                    <p class="mb-2"><strong>Browser Security Design:</strong></p>
                    <ul class="list-disc ml-4 space-y-1">
                        <li>Even when users grant file access, browsers intentionally hide absolute file system paths</li>
                        <li>This prevents websites from learning your file system structure (privacy protection)</li>
                        <li>The File System Access API gives file <em>content</em> access, not <em>path</em> access</li>
                        <li>Only files in the same directory as the webpage can be opened with real URLs</li>
                        <li>This is consistent across all modern browsers and by web standard design</li>
                    </ul>
                </div>
            </details>

            <!-- Search Bar - Centered below subtitle -->
            <div class="max-w-2xl mx-auto mb-8">
                <div class="search-container">
                    <div class="relative bg-white rounded-xl p-1">
                        <input 
                            type="text" 
                            id="searchInput" 
                            placeholder="Search HTML files..." 
                            class="w-full px-6 py-4 text-lg border-0 rounded-lg focus:outline-none focus:ring-0"
                        >
                        <button class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-blue-500 transition-colors">
                            <i class="fas fa-search text-xl"></i>
                        </button>
                    </div>
                </div>
            </div>

            <div class="text-sm text-gray-500 mb-8" id="directoryInfo">
                <i class="fas fa-folder mr-2"></i>
                <span id="currentPath">Scanning...</span>
            </div>
            
            <!-- Action Buttons -->
            <div class="flex flex-wrap justify-center gap-3 mb-8">
                <button 
                    id="selectFolderBtn" 
                    class="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white px-6 sm:px-8 py-4 sm:py-5 rounded-xl font-semibold shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center gap-2 sm:gap-3 text-lg"
                    title="Permanently add folders to your library for easy file access"
                >
                    <i class="fas fa-folder-open text-lg sm:text-xl"></i>
                    <span class="text-base sm:text-lg">Add Folders</span>
                </button>
                
                <button 
                    id="addFilesBtn" 
                    class="bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white px-4 sm:px-6 py-3 sm:py-4 rounded-xl font-semibold shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center gap-2 sm:gap-3"
                    title="Select files from your saved folder library"
                >
                    <i class="fas fa-file-plus text-sm sm:text-lg"></i>
                    <span class="text-sm sm:text-base">Add Files</span>
                </button>
                
                <button 
                    id="currentFolderBtn" 
                    class="bg-gray-600 hover:bg-gray-700 text-white px-4 sm:px-6 py-3 sm:py-4 rounded-xl font-semibold shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center gap-2 sm:gap-3"
                    title="Show current directory files"
                >
                    <i class="fas fa-home text-sm sm:text-lg"></i>
                    <span class="text-sm sm:text-base">Current Dir</span>
                </button>
                
                <button 
                    id="selectionModeBtn" 
                    class="bg-indigo-500 hover:bg-indigo-600 text-white px-4 sm:px-6 py-3 sm:py-4 rounded-xl font-semibold shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center gap-2 sm:gap-3"
                    title="Toggle multi-select mode for bulk actions"
                >
                    <i class="fas fa-check-square text-sm sm:text-lg"></i>
                    <span class="text-sm sm:text-base">Select</span>
                </button>
                
                <button 
                    id="openAllBtn" 
                    class="bg-orange-500 hover:bg-orange-600 text-white px-4 sm:px-6 py-3 sm:py-4 rounded-xl font-semibold shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center gap-2 sm:gap-3 hidden"
                    title="Open all selected files in new tabs"
                >
                    <i class="fas fa-external-link-alt text-sm sm:text-lg"></i>
                    <span class="text-sm sm:text-base">Open All</span>
                </button>
                
                <button 
                    id="resetBtn" 
                    class="bg-red-500 hover:bg-red-600 text-white px-4 sm:px-6 py-3 sm:py-4 rounded-xl font-semibold shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center gap-2 sm:gap-3"
                    title="Reset and clear all previews"
                >
                    <i class="fas fa-undo-alt text-sm sm:text-lg"></i>
                    <span class="text-sm sm:text-base">Reset</span>
                </button>
            </div>
            
            <!-- Bulk Action Panel (Hidden by default) -->
            <div id="bulkActionPanel" class="hidden bg-indigo-50 border border-indigo-200 rounded-xl p-4 mb-8 mx-auto max-w-4xl">
                <div class="flex flex-wrap items-center justify-between gap-4">
                    <div class="flex items-center gap-4">
                        <span id="selectedCount" class="font-semibold text-indigo-800">0 files selected</span>
                        <button id="selectAllBtn" class="text-indigo-600 hover:text-indigo-800 text-sm font-medium">
                            <i class="fas fa-check-double mr-1"></i>Select All
                        </button>
                        <button id="clearSelectionBtn" class="text-indigo-600 hover:text-indigo-800 text-sm font-medium">
                            <i class="fas fa-times mr-1"></i>Clear
                        </button>
                    </div>
                    <div class="flex gap-2">
                        <button id="bulkTagBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 rounded-lg text-sm font-medium">
                            <i class="fas fa-tag mr-1"></i>Tag
                        </button>
                        <button id="bulkFavoriteBtn" class="bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded-lg text-sm font-medium">
                            <i class="fas fa-heart mr-1"></i>Favorite
                        </button>
                        <button id="bulkBookmarkBtn" class="bg-green-500 hover:bg-green-600 text-white px-3 py-2 rounded-lg text-sm font-medium">
                            <i class="fas fa-bookmark mr-1"></i>Bookmark
                        </button>
                        <button id="bulkRemoveBtn" class="bg-orange-500 hover:bg-orange-600 text-white px-3 py-2 rounded-lg text-sm font-medium">
                            <i class="fas fa-eye-slash mr-1"></i>Hide
                        </button>
                        <button id="bulkDeleteBtn" class="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg text-sm font-medium">
                            <i class="fas fa-trash mr-1"></i>Delete
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Scan Depth Controls (shown when folder is selected) -->
            <div id="scanControls" class="hidden flex flex-wrap justify-center gap-3 mb-8 p-4 bg-blue-50 rounded-xl border border-blue-200">
                <div class="flex items-center gap-4">
                    <label class="text-blue-800 font-semibold">Scan Depth:</label>
                    <select id="scanDepth" class="px-3 py-2 border border-blue-300 rounded-lg bg-white">
                        <option value="10">Last 10 files</option>
                        <option value="25" selected>Last 25 files</option>
                        <option value="50">Last 50 files</option>
                        <option value="100">Last 100 files</option>
                        <option value="all">All files</option>
                    </select>
                    <button 
                        id="rescanBtn"
                        class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-medium"
                        title="Rescan with new depth setting"
                    >
                        <i class="fas fa-sync-alt mr-2"></i>Rescan
                    </button>
                </div>
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="includeSubdirs" checked>
                    <label for="includeSubdirs" class="text-blue-700">Include subdirectories</label>
                </div>
            </div>
            
            <!-- Hidden file inputs -->
            <input type="file" id="folderInput" webkitdirectory directory multiple style="display: none;" accept=".html,.htm">
        </div>
        
        <!-- Filter Controls -->
        <div class="flex flex-wrap justify-center gap-4 mb-8">
            <button class="filter-btn active px-6 py-3 rounded-full font-medium bg-white shadow-md" data-filter="all">
                <i class="fas fa-th-large mr-2"></i>All Files
            </button>
            <button class="filter-btn px-6 py-3 rounded-full font-medium bg-white shadow-md" data-filter="recent">
                <i class="fas fa-clock mr-2"></i>Recently Modified
            </button>
            <button class="filter-btn px-6 py-3 rounded-full font-medium bg-white shadow-md" data-filter="large">
                <i class="fas fa-expand-arrows-alt mr-2"></i>Large Files
            </button>
            <button class="filter-btn px-6 py-3 rounded-full font-medium bg-white shadow-md" data-filter="small">
                <i class="fas fa-compress-arrows-alt mr-2"></i>Small Files
            </button>
            <button class="filter-btn px-6 py-3 rounded-full font-medium bg-white shadow-md" data-filter="index">
                <i class="fas fa-home mr-2"></i>Index Files
            </button>
            <button class="filter-btn px-6 py-3 rounded-full font-medium bg-white shadow-md" data-filter="favorites">
                <i class="fas fa-heart mr-2"></i>Favorites <span id="favoritesCount" class="ml-1 text-xs bg-red-500 text-white px-2 py-1 rounded-full hidden">0</span>
            </button>
            <button class="filter-btn px-6 py-3 rounded-full font-medium bg-white shadow-md" data-filter="bookmarks">
                <i class="fas fa-bookmark mr-2"></i>Bookmarks <span id="bookmarksCount" class="ml-1 text-xs bg-green-500 text-white px-2 py-1 rounded-full hidden">0</span>
            </button>
            <button class="filter-btn px-6 py-3 rounded-full font-medium bg-white shadow-md" data-filter="tagged">
                <i class="fas fa-tags mr-2"></i>Tagged <span id="taggedCount" class="ml-1 text-xs bg-blue-500 text-white px-2 py-1 rounded-full hidden">0</span>
            </button>
            <button class="filter-btn px-6 py-3 rounded-full font-medium bg-white shadow-md" data-filter="external">
                <i class="fas fa-external-link-alt mr-2"></i>Has External Files
            </button>
        </div>
        
        <!-- Tag Filter Dropdown (shown when tagged filter is active) -->
        <div id="tagFilterDropdown" class="hidden max-w-2xl mx-auto mb-8">
            <div class="bg-white rounded-xl p-4 shadow-lg border border-blue-200">
                <div class="flex items-center gap-4 mb-3">
                    <label class="text-blue-800 font-semibold">Filter by tags:</label>
                    <select id="tagFilter" class="px-3 py-2 border border-blue-300 rounded-lg bg-white flex-1">
                        <option value="">All tagged files</option>
                    </select>
                    <button id="clearTagFilter" class="px-3 py-2 bg-gray-500 text-white rounded-lg text-sm">
                        <i class="fas fa-times mr-1"></i>Clear
                    </button>
                </div>
                <div id="availableTags" class="flex flex-wrap gap-2">
                    <!-- Tags will be populated here -->
                </div>
            </div>
        </div>
        
        <!-- Results Counter -->
        <div class="text-center mb-8">
            <p class="text-gray-600" id="resultsCounter">
                Found <span id="resultCount">0</span> HTML files
                <span id="sizeInfo" class="text-sm text-gray-500 block mt-1"></span>
            </p>
        </div>
        
        <!-- Files Grid -->
        <div id="filesGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mb-12">
            <!-- Files will be loaded here -->
        </div>
        
        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="text-center py-12">
            <div class="inline-flex items-center px-6 py-3 bg-white rounded-full shadow-lg">
                <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500 mr-3"></div>
                <span class="text-gray-600">Discovering HTML files...</span>
            </div>
        </div>
        
        <!-- No Results -->
        <div id="noResults" class="text-center py-20 hidden">
            <div class="max-w-md mx-auto">
                <div class="no-results-illustration">
                    <i class="fas fa-file-code text-6xl text-gray-400"></i>
                </div>
                <h3 class="text-2xl font-bold text-gray-600 mb-4">No HTML files found</h3>
                <p class="text-gray-500 mb-6">Place some HTML files in this directory to preview them</p>
                <div class="bg-gray-100 rounded-lg p-4 text-left max-w-sm mx-auto mb-6">
                    <h4 class="font-semibold text-gray-700 mb-2">Supported files:</h4>
                    <ul class="text-sm text-gray-600 space-y-1">
                        <li><i class="fas fa-check text-green-500 mr-2"></i>*.html</li>
                        <li><i class="fas fa-check text-green-500 mr-2"></i>*.htm</li>
                        <li><i class="fas fa-times text-red-500 mr-2"></i>This file (excluded)</li>
                    </ul>
                </div>
                
                <!-- Manual File Input -->
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 max-w-md mx-auto mb-6">
                    <h4 class="font-semibold text-blue-800 mb-3">Add Files Manually</h4>
                    <div class="flex gap-2 mb-2">
                        <input type="text" id="manualFileName" placeholder="filename.html" 
                               class="flex-1 px-3 py-2 border border-blue-300 rounded-lg text-sm">
                        <button onclick="addManualFile()" 
                                class="px-4 py-2 bg-blue-500 text-white rounded-lg text-sm hover:bg-blue-600">
                            <i class="fas fa-plus mr-1"></i>Add
                        </button>
                    </div>
                    <p class="text-xs text-blue-600">Enter filenames you know exist in this directory</p>
                </div>
                
                <!-- Session Restore Info -->
                <div id="sessionInfo" class="bg-green-50 border border-green-200 rounded-lg p-4 max-w-md mx-auto mb-6 hidden">
                    <h4 class="font-semibold text-green-800 mb-2">
                        <i class="fas fa-history mr-2"></i>Previous Session Available
                    </h4>
                    <p class="text-sm text-green-700 mb-3" id="sessionDetails"></p>
                    <div class="flex gap-2">
                        <button onclick="restoreSession()" 
                                class="px-4 py-2 bg-green-500 text-white rounded-lg text-sm hover:bg-green-600">
                            <i class="fas fa-undo mr-1"></i>Restore
                        </button>
                        <button onclick="clearSession()" 
                                class="px-4 py-2 bg-gray-500 text-white rounded-lg text-sm hover:bg-gray-600">
                            <i class="fas fa-times mr-1"></i>Start Fresh
                        </button>
                    </div>
                </div>
                
                <div class="flex gap-4 justify-center">
                    <button onclick="refreshFiles()" class="px-6 py-3 bg-blue-500 text-white rounded-full hover:bg-blue-600 transition-colors">
                        <i class="fas fa-sync-alt mr-2"></i>Refresh Directory
                    </button>
                    <button onclick="showManualMode()" class="px-6 py-3 bg-gray-500 text-white rounded-full hover:bg-gray-600 transition-colors">
                        <i class="fas fa-cog mr-2"></i>Manual Mode
                    </button>
                    <button onclick="showPathBrowser()" class="px-6 py-3 bg-purple-600 text-white rounded-full hover:bg-purple-700 transition-colors" title="üîß Fix File Paths - Browse to correct directory">
                        <i class="fas fa-route mr-2"></i>Fix Paths
                    </button>
                    <button onclick="nuclearReset()" class="px-6 py-3 bg-red-600 text-white rounded-full hover:bg-red-700 transition-colors" title="üö® Nuclear Reset - Wipe ALL data">
                        <i class="fas fa-radiation mr-2"></i>Nuclear Reset
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Error Message -->
        <div id="errorMessage" class="text-center py-20 hidden">
            <div class="max-w-md mx-auto">
                <div class="no-results-illustration">
                    <i class="fas fa-exclamation-triangle text-6xl text-amber-500"></i>
                </div>
                <h3 class="text-2xl font-bold text-gray-600 mb-4">CORS Security Restriction</h3>
                <p class="text-gray-500 mb-6">Browser security prevents local file access. This is normal when opening HTML files directly.</p>
                <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 text-left max-w-lg mx-auto mb-6">
                    <h4 class="font-semibold text-amber-800 mb-3">üöÄ Easy Solutions:</h4>
                    <div class="space-y-3 text-sm text-amber-700">
                        <div class="flex items-start gap-2">
                            <i class="fas fa-server text-amber-600 mt-1"></i>
                            <div>
                                <strong>Python:</strong> <code class="bg-amber-100 px-2 py-1 rounded">python -m http.server 8000</code>
                                <br><span class="text-xs">Then visit: http://localhost:8000</span>
                            </div>
                        </div>
                        <div class="flex items-start gap-2">
                            <i class="fas fa-node-js text-amber-600 mt-1"></i>
                            <div>
                                <strong>Node.js:</strong> <code class="bg-amber-100 px-2 py-1 rounded">npx live-server</code>
                                <br><span class="text-xs">Auto-opens browser with live reload</span>
                            </div>
                        </div>
                        <div class="flex items-start gap-2">
                            <i class="fas fa-code text-amber-600 mt-1"></i>
                            <div>
                                <strong>VS Code:</strong> Install "Live Server" extension
                                <br><span class="text-xs">Right-click HTML file ‚Üí "Open with Live Server"</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 max-w-md mx-auto mb-6">
                    <h4 class="font-semibold text-blue-800 mb-2">üìÅ Manual Mode Available</h4>
                    <p class="text-sm text-blue-700">You can still add files manually if you know their names</p>
                </div>
                <button onclick="refreshFiles()" class="mt-6 px-6 py-3 bg-amber-500 text-white rounded-full hover:bg-amber-600 transition-colors">
                    <i class="fas fa-redo mr-2"></i>Try Again
                </button>
            </div>
        </div>
    </div>

    <script>
        // Cross-Directory Tracker Network System
        let trackerNetwork = [];
        let networkScanInProgress = false;
        
        // Universal Directory Tracker System
        function createUniversalDirectoryTracker() {
            // Get our current location - this works 100% reliably from any directory
            const currentLocation = window.location.href;
            const currentDirectory = currentLocation.substring(0, currentLocation.lastIndexOf('/') + 1);
            const currentFileName = currentLocation.split('/').pop() || 'demoX.html';
            
            console.log(`üéØ Tracker Location: ${currentLocation}`);
            console.log(`üìÅ Directory Base: ${currentDirectory}`);
            console.log(`üìÑ Current File: ${currentFileName}`);
            
            return {
                directoryBase: currentDirectory,
                currentFile: currentFileName,
                canConstructRealPaths: true,
                
                // Build real file URL for any file - FIXED custom path mapping
                getFileUrl: function(filename) {
                    // PRIORITY 1: Check for custom path mapping first - THIS MUST OVERRIDE EVERYTHING
                    const customPathMapping = localStorage.getItem('htmlPreviewer_customPathMapping');
                    if (customPathMapping) {
                        try {
                            const pathConfig = JSON.parse(customPathMapping);
                            if (pathConfig.enabled && pathConfig.basePath) {
                                // Ensure proper path construction
                                let customUrl = pathConfig.basePath;
                                if (!customUrl.endsWith('/')) {
                                    customUrl += '/';
                                }
                                customUrl += filename;
                                
                                console.log(`üéØ CUSTOM PATH MAPPING ACTIVE for ${filename}:`);
                                console.log(`   Base path: ${pathConfig.basePath}`);
                                console.log(`   Final URL: ${customUrl}`);
                                return customUrl;
                            }
                        } catch (e) {
                            console.warn('Invalid custom path mapping:', e);
                        }
                    }
                    
                    // Dynamic path detection - use the actual folder path
                    console.log(`üîß NO CUSTOM MAPPING - using dynamic path detection for ${filename}`);
                    
                    // Use the current directory as base
                    const realUrl = this.directoryBase + filename;
                    console.log(`üîó Dynamic path for ${filename}: ${realUrl}`);
                    return realUrl;
                },
                
                // Check if a file exists (enhanced with better error handling)
                checkFileExists: async function(filename) {
                    try {
                        const url = this.getFileUrl(filename);
                        const response = await fetch(url, { 
                            method: 'HEAD',
                            cache: 'no-cache'
                        });
                        const exists = response.ok;
                        console.log(`‚úÖ File check ${filename}: ${exists ? 'EXISTS' : 'NOT FOUND'}`);
                        return exists;
                    } catch (error) {
                        console.log(`‚ùå File check ${filename}: ERROR - ${error.message}`);
                        return false;
                    }
                },
                
                // Get file info for existing files
                getFileInfo: async function(filename) {
                    try {
                        const url = this.getFileUrl(filename);
                        const response = await fetch(url, { method: 'HEAD' });
                        if (!response.ok) return null;
                        
                        const lastModified = response.headers.get('last-modified');
                        const contentLength = response.headers.get('content-length');
                        
                        return {
                            lastModified: lastModified ? new Date(lastModified) : new Date(),
                            size: contentLength ? parseInt(contentLength) : 0,
                            sizeFormatted: contentLength ? formatFileSize(parseInt(contentLength)) : 'Unknown'
                        };
                    } catch (error) {
                        console.warn(`Could not get file info for ${filename}:`, error);
                        return {
                            lastModified: new Date(),
                            size: 0,
                            sizeFormatted: 'Unknown'
                        };
                    }
                },
                
                // Discover all HTML files in this directory using multiple strategies
                discoverLocalFiles: async function() {
                    const foundFiles = [];
                    const checkedFiles = new Set();
                    
                    // Strategy 1: Check common HTML file patterns
                    const commonPatterns = [
                        'index.html', 'index.htm', 'home.html', 'main.html', 'app.html',
                        'page.html', 'test.html', 'demo.html', 'sample.html', 'template.html',
                        'about.html', 'contact.html', 'portfolio.html', 'gallery.html',
                        'blog.html', 'shop.html', 'dashboard.html', 'landing.html',
                        'login.html', 'signup.html', 'profile.html', 'settings.html'
                    ];
                    
                    console.log('üîç Strategy 1: Checking common patterns...');
                    for (const pattern of commonPatterns) {
                        if (pattern !== this.currentFile && !checkedFiles.has(pattern)) {
                            checkedFiles.add(pattern);
                            if (await this.checkFileExists(pattern)) {
                                const fileInfo = await this.getFileInfo(pattern);
                                const realUrl = this.getFileUrl(pattern);
                                foundFiles.push({
                                    name: pattern,
                                    path: realUrl,
                                    originalPath: realUrl,
                                    displayName: pattern.replace(/\.(html|htm)$/i, ''),
                                    method: 'tracker-discovered',
                                    realPathAvailable: true,
                                    discovered: true,
                                    ...fileInfo
                                });
                                
                                // Save absolute path for permanent access
                                saveAbsoluteFilePath(pattern, realUrl, {
                                    source: 'universal-tracker',
                                    method: 'pattern-discovery'
                                });
                                
                                console.log(`‚úÖ Found: ${pattern}`);
                            }
                        }
                    }
                    
                    // Strategy 2: Cross-directory file discovery for GENERATOR Apps structure
                    console.log('üîç Strategy 2: Cross-directory discovery...');
                    
                    const crossDirectoryFiles = [
                        // WealthBox files
                        { name: 'index.html', dir: 'WealthBox/Website/', displayName: 'WealthBox - Main' },
                        { name: 'display.html', dir: 'WealthBox/Website/', displayName: 'WealthBox - Display' },
                        { name: 'index.html', dir: 'WealthBox/Backup/WealthBox Doc Gen 1.1/Website/', displayName: 'WealthBox Backup' },
                        
                        // Diet Planner files
                        { name: 'index.html', dir: 'DietPlanner Pro/Website/', displayName: 'Diet Planner - Main' },
                        { name: 'app.html', dir: 'DietPlanner Pro/Website/', displayName: 'Diet Planner - App' },
                        { name: 'display.html', dir: 'DietPlanner Pro/Website/', displayName: 'Diet Planner - Display' },
                        
                        // Trading Dashboard files
                        { name: 'index.html', dir: 'Trading Dashboard/Website/', displayName: 'Trading Dashboard - Main' },
                        { name: 'app.html', dir: 'Trading Dashboard/Website/', displayName: 'Trading Dashboard - App' },
                        { name: 'display.html', dir: 'Trading Dashboard/Website/', displayName: 'Trading Dashboard - Display' },
                        
                        // Focus Matrix files
                        { name: 'demo.html', dir: 'Focus Matrix/', displayName: 'Focus Matrix - Demo' },
                        { name: 'FOcus Matrix Advanced 1.1..html', dir: 'Focus Matrix/', displayName: 'Focus Matrix Advanced' },
                        
                        // Current directory files (Bulk Generator)
                        { name: 'Home.html', dir: '', displayName: 'Home' },
                        { name: 'demoX.html', dir: '', displayName: 'Universal HTML Previewer' },
                        { name: 'demo.html', dir: '', displayName: 'Demo' },
                        
                        // Main Files directory
                        { name: 'index.html', dir: 'Main Files/home/', displayName: 'Main Files - Home' }
                    ];
                    
                    for (const fileSpec of crossDirectoryFiles) {
                        if (fileSpec.name !== this.currentFile && !checkedFiles.has(fileSpec.name + fileSpec.dir)) {
                            checkedFiles.add(fileSpec.name + fileSpec.dir);
                            
                            // Construct the full path
                            let fullPath;
                            if (fileSpec.dir === '') {
                                // Current directory
                                fullPath = this.directoryBase + fileSpec.name;
                            } else {
                                // Other directory
                                fullPath = this.directoryBase.replace(/Bulk\s*Generator[^/]*\/?$/, fileSpec.dir) + fileSpec.name;
                            }
                            
                            console.log(`üîç Checking cross-directory file: ${fullPath}`);
                            
                            try {
                                const response = await fetch(fullPath, { method: 'HEAD', cache: 'no-cache' });
                                if (response.ok) {
                                    const lastModified = response.headers.get('last-modified');
                                    const contentLength = response.headers.get('content-length');
                                    
                                    foundFiles.push({
                                        name: fileSpec.displayName + '.html',
                                        path: fullPath,
                                        originalPath: fullPath,
                                        displayName: fileSpec.displayName,
                                        method: 'cross-directory-discovered',
                                        realPathAvailable: true,
                                        discovered: true,
                                        directory: fileSpec.dir || 'Bulk Generator',
                                        lastModified: lastModified ? new Date(lastModified) : new Date(),
                                        size: contentLength ? parseInt(contentLength) : 0,
                                        sizeFormatted: contentLength ? formatFileSize(parseInt(contentLength)) : 'Unknown'
                                    });
                                    
                                    // Save absolute path for permanent access
                                    saveAbsoluteFilePath(fileSpec.displayName + '.html', fullPath, {
                                        source: 'cross-directory-tracker',
                                        method: 'cross-directory-discovery',
                                        directory: fileSpec.dir
                                    });
                                    
                                    console.log(`‚úÖ Found cross-directory: ${fileSpec.displayName} at ${fullPath}`);
                                }
                            } catch (error) {
                                console.log(`‚ùå Cross-directory check failed for ${fileSpec.displayName}: ${error.message}`);
                            }
                        }
                    }
                    
                    // Strategy 2b: Check files specific to current directory
                    const yourSpecificFiles = [
                        'Home.html', 'Home - Copy.html', 'Home - Copy (2).html', 'Home - Copy (3).html',
                        'create-a-self-contained-indexhtml-file-t-810.html',
                        'file-cards-each-preview-in-a-white-card-824.html',
                        'header-bar-clean-title-html-file-explore-162.html',
                        'main-grid-responsive-masonry-layout-3-5-773.html',
                        '-1-modern-file-explorer-ui-389.html',
                        '-1-developer-focused-thumbnail-gallery-w-978.html',
                        'demo.html', 'demo - Copy.html', 'demo - Copy (2).html', 'demo - Copy (3).html',
                        'demoX.html', 'demoX - Copy.html', 'demoX_updated.html'
                    ];
                    
                    console.log('üîç Strategy 2b: Checking current directory files...');
                    for (const filename of yourSpecificFiles) {
                        if (filename !== this.currentFile && !checkedFiles.has(filename)) {
                            checkedFiles.add(filename);
                            if (await this.checkFileExists(filename)) {
                                const fileInfo = await this.getFileInfo(filename);
                                const realUrl = this.getFileUrl(filename);
                                foundFiles.push({
                                    name: filename,
                                    path: realUrl,
                                    originalPath: realUrl,
                                    displayName: filename.replace(/\.(html|htm)$/i, ''),
                                    method: 'tracker-discovered',
                                    realPathAvailable: true,
                                    discovered: true,
                                    ...fileInfo
                                });
                                
                                // Save absolute path for permanent access
                                saveAbsoluteFilePath(filename, realUrl, {
                                    source: 'universal-tracker',
                                    method: 'specific-files'
                                });
                                
                                console.log(`‚úÖ Found current directory: ${filename}`);
                            }
                        }
                    }
                    
                    // Strategy 3: Try to fetch directory listing if possible
                    console.log('üîç Strategy 3: Attempting directory listing...');
                    try {
                        const response = await fetch('./');
                        if (response.ok) {
                            const html = await response.text();
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(html, 'text/html');
                            
                            // Look for directory listing links
                            const links = doc.querySelectorAll('a[href]');
                            for (const link of links) {
                                const href = link.getAttribute('href');
                                
                                // Only include files that are HTML and in current directory
                                if (href && 
                                    (href.endsWith('.html') || href.endsWith('.htm')) && 
                                    href !== this.currentFile && 
                                    !href.startsWith('http') && 
                                    !href.includes('/') && 
                                    !href.includes('..') &&
                                    !href.includes('\\') &&
                                    !checkedFiles.has(href)) {
                                    
                                    checkedFiles.add(href);
                                    const fileInfo = await this.getFileInfo(href);
                                    foundFiles.push({
                                        name: href,
                                        path: this.getFileUrl(href),
                                        originalPath: this.getFileUrl(href),
                                        displayName: href.replace(/\.(html|htm)$/i, ''),
                                        method: 'tracker-directory-listing',
                                        realPathAvailable: true,
                                        discovered: true,
                                        ...fileInfo
                                    });
                                    console.log(`‚úÖ Found via directory listing: ${href}`);
                                }
                            }
                        }
                    } catch (error) {
                        console.log('Directory listing not available:', error.message);
                    }
                    
                    console.log(`üéâ Discovery complete! Found ${foundFiles.length} HTML files with REAL paths`);
                    return foundFiles;
                }
            };
        }

        // Simplified folder scanning - no complex network discovery needed
        
        // Function to scan a specific tracker directory
        async function scanTrackerDirectory(tracker) {
            try {
                showStatus(`üîÑ Scanning ${tracker.folderName} tracker...`, 'scanning');
                
                // Create a remote tracker instance
                const remoteTracker = {
                    directoryBase: tracker.directory,
                    currentFile: 'DemoTracker.html',
                    
                    getFileUrl: function(filename) {
                        return this.directoryBase + filename;
                    },
                    
                    checkFileExists: async function(filename) {
                        try {
                            const response = await fetch(this.getFileUrl(filename), { method: 'HEAD' });
                            return response.ok;
                        } catch {
                            return false;
                        }
                    },
                    
                    getFileInfo: async function(filename) {
                        try {
                            const response = await fetch(this.getFileUrl(filename), { method: 'HEAD' });
                            if (!response.ok) return null;
                            
                            const lastModified = response.headers.get('last-modified');
                            const contentLength = response.headers.get('content-length');
                            
                            return {
                                lastModified: lastModified ? new Date(lastModified) : new Date(),
                                size: contentLength ? parseInt(contentLength) : 0,
                                sizeFormatted: contentLength ? formatFileSize(parseInt(contentLength)) : 'Unknown'
                            };
                        } catch {
                            return {
                                lastModified: new Date(),
                                size: 0,
                                sizeFormatted: 'Unknown'
                            };
                        }
                    }
                };
                
                // Scan for HTML files in that directory
                const patterns = [
                    'index.html', 'index.htm', 'home.html', 'main.html', 'app.html',
                    'demo.html', 'test.html', 'sample.html', 'template.html',
                    'about.html', 'contact.html', 'portfolio.html', 'gallery.html'
                ];
                
                const remoteFiles = [];
                for (const pattern of patterns) {
                    if (await remoteTracker.checkFileExists(pattern)) {
                        const fileInfo = await remoteTracker.getFileInfo(pattern);
                        remoteFiles.push({
                            name: pattern,
                            path: remoteTracker.getFileUrl(pattern),
                            originalPath: remoteTracker.getFileUrl(pattern),
                            displayName: `${tracker.folderName}/${pattern.replace(/\.(html|htm)$/i, '')}`,
                            method: 'remote-tracker',
                            realPathAvailable: true,
                            discovered: true,
                            trackerSource: tracker.folderName,
                            trackerUrl: tracker.url,
                            ...fileInfo
                        });
                    }
                }
                
                if (remoteFiles.length > 0) {
                    // Add remote files to allFiles
                    allFiles.push(...remoteFiles);
                    
                    // Update display
                    displayedItems = 0;
                    loadFiles();
                    saveLastSession();
                    
                    showStatus(`üìÅ Loaded ${remoteFiles.length} files from ${tracker.folderName}`, 'success');
                    
                    return remoteFiles;
                } else {
                    showStatus(`üìÇ No HTML files found in ${tracker.folderName}`, 'error');
                    return [];
                }
                
            } catch (error) {
                console.error(`Error scanning tracker ${tracker.folderName}:`, error);
                showStatus(`‚ùå Error scanning ${tracker.folderName}`, 'error');
                return [];
            }
        }

        // State management
        let currentFilter = 'all';
        let currentSearch = '';
        let allFiles = [];
        let displayedItems = 0;
        const itemsPerPage = 12;
        const currentFileName = window.location.pathname.split('/').pop() || 'demoX.html';
        let universalTracker = null; // Will be initialized on load
        
        // Helper function to get current directory name
        function getCurrentDirectoryName() {
            const currentPath = decodeURIComponent(window.location.pathname);
            const pathParts = currentPath.split('/').filter(part => part.length > 0);
            return pathParts.length > 0 ? pathParts[pathParts.length - 1] : '';
        }
        

        
        // Enhanced Persistence Management with Absolute Path Storage
        let favorites = new Set();
        let bookmarkedFiles = new Set();
        let fileTags = new Map(); // fileName -> Set of tags
        let selectedFiles = new Set(); // For bulk operations
        let savedFolders = new Map(); // folder path -> folder info with absolute paths
        let fileNotes = new Map(); // fileName -> note text
        let fileRatings = new Map(); // fileName -> 1-5 rating
        let recentFiles = []; // Recently accessed files with absolute paths
        let workspaces = new Map(); // workspace name -> file list with absolute paths
        let absoluteFilePaths = new Map(); // fileName -> absolute file:// URL for permanent access
        
        // Storage keys
        const FAVORITES_STORAGE_KEY = 'htmlPreviewer_favorites';
        const BOOKMARKS_STORAGE_KEY = 'htmlPreviewer_bookmarks';
        const LAST_SESSION_KEY = 'htmlPreviewer_lastSession';
        const USER_PREFERENCES_KEY = 'htmlPreviewer_preferences';
        const FILE_TAGS_KEY = 'htmlPreviewer_fileTags';
        const SAVED_FOLDERS_KEY = 'htmlPreviewer_savedFolders';
        const FILE_NOTES_KEY = 'htmlPreviewer_fileNotes';
        const FILE_RATINGS_KEY = 'htmlPreviewer_fileRatings';
        const RECENT_FILES_KEY = 'htmlPreviewer_recentFiles';
        const WORKSPACES_KEY = 'htmlPreviewer_workspaces';
        const LAST_FOLDER_KEY = 'htmlPreviewer_lastFolder';
        const ABSOLUTE_PATHS_KEY = 'htmlPreviewer_absolutePaths';
        
        // UI State
        let isSelectionMode = false;
        let bulkActionPanel = null;
        
        // Bookmark management
        let bookmarkFolder = ''; // Default bookmark folder
        let hasShownBookmarkInstructions = false; // Track if we've shown instructions

        // Enhanced persistence functions with error handling and validation
        function loadFavorites() {
            try {
                const saved = localStorage.getItem(FAVORITES_STORAGE_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    favorites = new Set(Array.isArray(data) ? data : []);
                }
            } catch (e) {
                console.warn('Failed to load favorites:', e);
                favorites = new Set();
            }
            updateFavoritesCount();
        }
        
        function loadAllData() {
            try {
                // Load favorites
                loadFavorites();
                loadBookmarks();
                
                // Load file tags
                const tagsData = localStorage.getItem(FILE_TAGS_KEY);
                if (tagsData) {
                    const parsed = JSON.parse(tagsData);
                    fileTags = new Map(Object.entries(parsed).map(([key, value]) => [key, new Set(value)]));
                }
                
                // Load saved folders
                const foldersData = localStorage.getItem(SAVED_FOLDERS_KEY);
                if (foldersData) {
                    savedFolders = new Map(Object.entries(JSON.parse(foldersData)));
                }
                
                // Load file notes
                const notesData = localStorage.getItem(FILE_NOTES_KEY);
                if (notesData) {
                    fileNotes = new Map(Object.entries(JSON.parse(notesData)));
                }
                
                // Load file ratings
                const ratingsData = localStorage.getItem(FILE_RATINGS_KEY);
                if (ratingsData) {
                    fileRatings = new Map(Object.entries(JSON.parse(ratingsData)));
                }
                
                // Load recent files
                const recentData = localStorage.getItem(RECENT_FILES_KEY);
                if (recentData) {
                    recentFiles = JSON.parse(recentData).slice(0, 10); // Limit to 10
                }
                
                // Load workspaces
                const workspacesData = localStorage.getItem(WORKSPACES_KEY);
                if (workspacesData) {
                    workspaces = new Map(Object.entries(JSON.parse(workspacesData)));
                }
                
                // Load absolute file paths
                const absolutePathsData = localStorage.getItem(ABSOLUTE_PATHS_KEY);
                if (absolutePathsData) {
                    absoluteFilePaths = new Map(Object.entries(JSON.parse(absolutePathsData)));
                }
                
                console.log('‚úÖ All data loaded successfully');
                console.log(`üìä Loaded data: ${favorites.size} favorites, ${fileTags.size} tagged files, ${absoluteFilePaths.size} absolute paths`);
                updateAllCounters();
                
            } catch (e) {
                console.error('‚ùå Error loading data:', e);
                showStatus('Error loading saved data - starting fresh', 'error');
            }
        }
        
        function saveAllData() {
            try {
                // Save with error handling for each item
                const saveItem = (key, data) => {
                    try {
                        localStorage.setItem(key, JSON.stringify(data));
                    } catch (e) {
                        console.warn(`Failed to save ${key}:`, e);
                        // Try to free up space by removing old session data
                        if (e.name === 'QuotaExceededError') {
                            localStorage.removeItem(LAST_SESSION_KEY);
                            try {
                                localStorage.setItem(key, JSON.stringify(data));
                            } catch (e2) {
                                console.error(`Still failed to save ${key}:`, e2);
                            }
                        }
                    }
                };
                
                saveFavorites();
                saveBookmarks();
                
                // Save file tags (convert Map to Object)
                const tagsObj = Object.fromEntries(
                    Array.from(fileTags.entries()).map(([key, value]) => [key, Array.from(value)])
                );
                saveItem(FILE_TAGS_KEY, tagsObj);
                
                // Save saved folders
                saveItem(SAVED_FOLDERS_KEY, Object.fromEntries(savedFolders));
                
                // Save file notes
                saveItem(FILE_NOTES_KEY, Object.fromEntries(fileNotes));
                
                // Save file ratings
                saveItem(FILE_RATINGS_KEY, Object.fromEntries(fileRatings));
                
                // Save recent files (limit to 10)
                saveItem(RECENT_FILES_KEY, recentFiles.slice(0, 10));
                
                // Save workspaces
                saveItem(WORKSPACES_KEY, Object.fromEntries(workspaces));
                
                // Save absolute file paths
                saveItem(ABSOLUTE_PATHS_KEY, Object.fromEntries(absoluteFilePaths));
                
                console.log('‚úÖ All data saved successfully');
                console.log(`üíæ Saved data: ${favorites.size} favorites, ${fileTags.size} tagged files, ${absoluteFilePaths.size} absolute paths`);
                
            } catch (e) {
                console.error('‚ùå Error saving data:', e);
                showStatus('Error saving data', 'error');
            }
        }

        function loadBookmarks() {
            try {
                const saved = localStorage.getItem(BOOKMARKS_STORAGE_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    bookmarkedFiles = new Set(data.files || []);
                    bookmarkFolder = data.folder || '';
                }
            } catch (e) {
                console.warn('Failed to load bookmarks:', e);
                bookmarkedFiles = new Set();
                bookmarkFolder = '';
            }
        }

        function saveBookmarks() {
            try {
                const data = {
                    files: [...bookmarkedFiles],
                    folder: bookmarkFolder
                };
                localStorage.setItem(BOOKMARKS_STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                console.warn('Failed to save bookmarks:', e);
            }
        }

        function saveLastSession() {
            try {
                const sessionData = {
                    files: allFiles.map(file => ({
                        name: file.name,
                        path: file.path,
                        originalPath: file.originalPath,
                        displayName: file.displayName,
                        lastModified: file.lastModified?.toISOString(),
                        size: file.size,
                        sizeFormatted: file.sizeFormatted,
                        method: file.method,
                        discovered: file.discovered,
                        manual: file.manual
                    })),
                    currentFilter: currentFilter,
                    currentSearch: currentSearch,
                    isShowingFolderFiles: isShowingFolderFiles,
                    timestamp: new Date().toISOString(),
                    currentPath: document.getElementById('currentPath')?.textContent || '',
                    fileCount: allFiles.length
                };
                localStorage.setItem(LAST_SESSION_KEY, JSON.stringify(sessionData));
                console.log(`Session saved: ${allFiles.length} files, filter: ${currentFilter}`);
            } catch (e) {
                console.warn('Failed to save session:', e);
            }
        }

        function loadLastSession() {
            try {
                const saved = localStorage.getItem(LAST_SESSION_KEY);
                if (!saved) return false;

                const sessionData = JSON.parse(saved);
                
                // Check if session is not too old (older than 7 days)
                const sessionAge = Date.now() - new Date(sessionData.timestamp).getTime();
                const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
                
                if (sessionAge > maxAge) {
                    console.log('Session too old, starting fresh');
                    localStorage.removeItem(LAST_SESSION_KEY);
                    return false;
                }

                // Restore files
                allFiles = sessionData.files.map(file => ({
                    ...file,
                    lastModified: file.lastModified ? new Date(file.lastModified) : new Date()
                }));

                // Restore state
                currentFilter = sessionData.currentFilter || 'all';
                currentSearch = sessionData.currentSearch || '';
                isShowingFolderFiles = sessionData.isShowingFolderFiles || false;
                
                // Update UI elements
                const searchInput = document.getElementById('searchInput');
                if (searchInput) searchInput.value = currentSearch;
                
                // Update filter buttons
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.filter === currentFilter) {
                        btn.classList.add('active');
                    }
                });

                // Update directory info
                if (sessionData.currentPath) {
                    document.getElementById('currentPath').textContent = sessionData.currentPath;
                }

                // Update folder buttons
                updateFolderButtons();

                console.log(`Session restored: ${allFiles.length} files from ${sessionData.timestamp}`);
                showStatus(`Restored session with ${allFiles.length} files`, 'success');
                
                return true;
            } catch (e) {
                console.warn('Failed to load session:', e);
                localStorage.removeItem(LAST_SESSION_KEY);
                return false;
            }
        }

        function saveUserPreferences() {
            try {
                const preferences = {
                    defaultFilter: currentFilter,
                    searchHistory: getSearchHistory(),
                    viewMode: 'grid', // Future: list/grid toggle
                    itemsPerPage: itemsPerPage,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(USER_PREFERENCES_KEY, JSON.stringify(preferences));
            } catch (e) {
                console.warn('Failed to save preferences:', e);
            }
        }

        function loadUserPreferences() {
            try {
                const saved = localStorage.getItem(USER_PREFERENCES_KEY);
                if (saved) {
                    const preferences = JSON.parse(saved);
                    // Apply preferences as needed
                    return preferences;
                }
            } catch (e) {
                console.warn('Failed to load preferences:', e);
            }
            return null;
        }

        function clearStoredData() {
            try {
                // Clear all localStorage items
                localStorage.removeItem(LAST_SESSION_KEY);
                localStorage.removeItem(FAVORITES_STORAGE_KEY);
                localStorage.removeItem(BOOKMARKS_STORAGE_KEY);
                localStorage.removeItem(USER_PREFERENCES_KEY);
                localStorage.removeItem(FILE_TAGS_KEY);
                localStorage.removeItem(SAVED_FOLDERS_KEY);
                localStorage.removeItem(FILE_NOTES_KEY);
                localStorage.removeItem(FILE_RATINGS_KEY);
                localStorage.removeItem(RECENT_FILES_KEY);
                localStorage.removeItem(WORKSPACES_KEY);
                localStorage.removeItem(LAST_FOLDER_KEY);
                localStorage.removeItem(ABSOLUTE_PATHS_KEY);
                localStorage.removeItem('customPathMapping'); // Clear path mapping
                
                // Clear all in-memory data
                favorites.clear();
                bookmarkedFiles.clear();
                fileTags.clear();
                savedFolders.clear();
                fileNotes.clear();
                fileRatings.clear();
                recentFiles.length = 0;
                workspaces.clear();
                selectedFiles.clear();
                absoluteFilePaths.clear();
                
                // CRITICAL: Clear the main files array
                allFiles = [];
                displayedItems = 0;
                currentSearch = '';
                currentFilter = 'all';
                isShowingFolderFiles = false;
                window.selectedFolderFiles = null;
                window.lastDirectoryHandle = null;
                
                // Clear the grid display
                const grid = document.getElementById('filesGrid');
                if (grid) grid.innerHTML = '';
                
                // Reset UI elements
                const searchInput = document.getElementById('searchInput');
                if (searchInput) searchInput.value = '';
                
                // Reset filter buttons
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.filter === 'all') {
                        btn.classList.add('active');
                    }
                });
                
                // Reset directory info
                document.getElementById('currentPath').textContent = 'Current directory (no files loaded)';
                
                // Reset counters
                document.getElementById('resultCount').textContent = '0';
                document.getElementById('sizeInfo').textContent = '';
                
                // Update all counters
                updateAllCounters();
                
                // Show no results state
                showNoResults();
                
                showStatus('All stored data and files cleared successfully', 'success');
                
                // Save empty session to prevent restoration
                saveLastSession();
                
            } catch (e) {
                console.warn('Failed to clear stored data:', e);
                showStatus('Error clearing data', 'error');
            }
        }

        // Global flag to prevent auto-scanning after explicit clear
        let preventAutoScanning = false;
        
        // Nuclear reset function to completely wipe everything
        function nuclearReset() {
            if (!confirm('üö® NUCLEAR RESET üö®\n\nThis will completely wipe ALL data including:\n‚Ä¢ All files and previews\n‚Ä¢ All favorites and bookmarks\n‚Ä¢ All saved folders and sessions\n‚Ä¢ All preferences and settings\n‚Ä¢ All tags and notes\n\nThis action CANNOT be undone!\n\nAre you absolutely sure?')) {
                return;
            }
            
            try {
                // Set flag to prevent auto-scanning
                preventAutoScanning = true;
                
                // Clear EVERYTHING from localStorage
                const keys = Object.keys(localStorage);
                keys.forEach(key => {
                    if (key.startsWith('htmlPreviewer') || 
                        key.includes('session') || 
                        key.includes('favorite') || 
                        key.includes('bookmark') ||
                        key.includes('tag') ||
                        key.includes('folder') ||
                        key.includes('customPath')) {
                        localStorage.removeItem(key);
                    }
                });
                
                // Clear the specific keys we know about
                localStorage.removeItem(LAST_SESSION_KEY);
                localStorage.removeItem(FAVORITES_STORAGE_KEY);
                localStorage.removeItem(BOOKMARKS_STORAGE_KEY);
                localStorage.removeItem(USER_PREFERENCES_KEY);
                localStorage.removeItem(FILE_TAGS_KEY);
                localStorage.removeItem(SAVED_FOLDERS_KEY);
                localStorage.removeItem(FILE_NOTES_KEY);
                localStorage.removeItem(FILE_RATINGS_KEY);
                localStorage.removeItem(RECENT_FILES_KEY);
                localStorage.removeItem(WORKSPACES_KEY);
                localStorage.removeItem(LAST_FOLDER_KEY);
                localStorage.removeItem(ABSOLUTE_PATHS_KEY);
                localStorage.removeItem('customPathMapping');
                localStorage.removeItem('htmlPreviewer_customPathMapping');
                
                // Set a special flag to prevent auto-discovery
                localStorage.setItem('htmlPreviewer_preventAutoScan', 'true');
                
                // Clear all global variables
                allFiles = [];
                favorites.clear();
                bookmarkedFiles.clear();
                fileTags.clear();
                savedFolders.clear();
                fileNotes.clear();
                fileRatings.clear();
                recentFiles.length = 0;
                workspaces.clear();
                selectedFiles.clear();
                absoluteFilePaths.clear();
                
                // Reset all state variables
                displayedItems = 0;
                currentSearch = '';
                currentFilter = 'all';
                isShowingFolderFiles = false;
                window.selectedFolderFiles = null;
                window.lastDirectoryHandle = null;
                
                // Clear all UI
                const grid = document.getElementById('filesGrid');
                if (grid) grid.innerHTML = '';
                
                const searchInput = document.getElementById('searchInput');
                if (searchInput) searchInput.value = '';
                
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.filter === 'all') {
                        btn.classList.add('active');
                    }
                });
                
                document.getElementById('currentPath').textContent = 'No files loaded - Auto-scan disabled';
                document.getElementById('resultCount').textContent = '0';
                document.getElementById('sizeInfo').textContent = '';
                
                // Clear any bulk selection
                exitSelectionMode();
                
                // Update all counters
                updateAllCounters();
                
                // Show clean state
                showNoResults();
                
                showStatus('üö® NUCLEAR RESET COMPLETE - Auto-scanning disabled to prevent file re-discovery', 'success');
                
                console.log('üö® Nuclear reset complete. Auto-scanning disabled.');
                console.log('üí° Use refreshFiles() or window.enableAutoScan() to re-enable scanning.');
                
                // Optional: Reload page for complete fresh start
                if (confirm('Reload page for complete fresh start? (Recommended)')) {
                    localStorage.removeItem('htmlPreviewer_preventAutoScan'); // Allow scanning on fresh reload
                    window.location.reload();
                }
                
            } catch (e) {
                console.error('Nuclear reset failed:', e);
                showStatus('Nuclear reset failed - try refreshing page', 'error');
            }
        }

        // Search history management
        let searchHistory = [];
        const MAX_SEARCH_HISTORY = 10;

        function addToSearchHistory(query) {
            if (!query || query.length < 2) return;
            
            // Remove if already exists
            searchHistory = searchHistory.filter(item => item !== query);
            // Add to beginning
            searchHistory.unshift(query);
            // Limit size
            searchHistory = searchHistory.slice(0, MAX_SEARCH_HISTORY);
            
            saveUserPreferences();
        }

        function getSearchHistory() {
            return searchHistory;
        }

        function saveFavorites() {
            try {
                localStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify([...favorites]));
            } catch (e) {
                console.warn('Failed to save favorites:', e);
            }
        }

        function toggleFavorite(fileName) {
            if (favorites.has(fileName)) {
                favorites.delete(fileName);
                showStatus(`Removed ${fileName} from favorites`, 'success');
            } else {
                favorites.add(fileName);
                showStatus(`Added ${fileName} to favorites`, 'success');
            }
            saveFavorites();
            updateFavoritesCount();
            
            // Update the button state
            updateFavoriteButton(fileName);
            
                                    // If currently viewing favorites or bookmarks, refresh the view
                        if (currentFilter === 'favorites' || currentFilter === 'bookmarks') {
                            displayedItems = 0;
                            loadFiles();
                        }
        }

        function updateFavoriteButton(fileName) {
            const cards = document.querySelectorAll('.style-card');
            cards.forEach(card => {
                const cardFileName = card.dataset.fileName;
                if (cardFileName === fileName) {
                    const favoriteBtn = card.querySelector('.favorite-btn');
                    const icon = favoriteBtn.querySelector('i');
                    
                    if (favorites.has(fileName)) {
                        favoriteBtn.classList.add('favorited');
                        icon.className = 'fas fa-heart';
                    } else {
                        favoriteBtn.classList.remove('favorited');
                        icon.className = 'far fa-heart';
                    }
                }
            });
        }

        function updateFavoritesCount() {
            const countElement = document.getElementById('favoritesCount');
            const count = favorites.size;
            
            if (count > 0) {
                countElement.textContent = count;
                countElement.classList.remove('hidden');
            } else {
                countElement.classList.add('hidden');
            }
        }

        function updateBookmarksCount() {
            const countElement = document.getElementById('bookmarksCount');
            const count = bookmarkedFiles.size;
            
            if (count > 0) {
                countElement.textContent = count;
                countElement.classList.remove('hidden');
            } else {
                countElement.classList.add('hidden');
            }
        }

        function isFavorited(fileName) {
            return favorites.has(fileName);
        }

        // Bookmark functions
        function toggleBookmark(fileName, filePath, originalPath) {
            if (bookmarkedFiles.has(fileName)) {
                bookmarkedFiles.delete(fileName);
                saveBookmarks();
                updateBookmarkButton(fileName);
                updateBookmarksCount();
                showStatus(`Removed ${fileName} from bookmarks`, 'success');
            } else {
                addBookmark(fileName, filePath, originalPath);
            }
        }

        async function addBookmark(fileName, filePath, originalPath) {
            try {
                // Use original path if available, otherwise use the current path
                const pathToUse = originalPath || filePath;
                const fullUrl = pathToUse.startsWith('blob:') ? 
                    window.location.href.replace(window.location.pathname.split('/').pop(), fileName) :
                    new URL(pathToUse, window.location.href).href;
                const title = fileName.replace(/\.(html|htm)$/i, '');
                
                if (bookmarkFolder === '') {
                    // First time - ask for bookmark location
                    const folder = prompt(
                        'Choose a bookmark folder name (or leave empty for default bookmarks):\n\n' +
                        'Examples:\n' +
                        '‚Ä¢ HTML Projects\n' +
                        '‚Ä¢ Web Designs\n' +
                        '‚Ä¢ Templates\n' +
                        '‚Ä¢ Leave empty for default location',
                        'HTML Previewer'
                    );
                    
                    if (folder === null) return; // User cancelled
                    bookmarkFolder = folder || 'HTML Previewer';
                    saveBookmarks();
                }
                
                // Try to add bookmark using the Bookmark API if available
                if (window.external && window.external.AddFavorite) {
                    // Internet Explorer
                    window.external.AddFavorite(fullUrl, title);
                } else if (window.sidebar && window.sidebar.addPanel) {
                    // Old Firefox
                    window.sidebar.addPanel(title, fullUrl, '');
                } else {
                    // Modern browsers - show instructions only once per session
                    if (!hasShownBookmarkInstructions) {
                        const isCtrlCmd = navigator.platform.includes('Mac') ? 'Cmd' : 'Ctrl';
                        const instructions = 
                            `To bookmark "${title}":\n\n` +
                            `1. Press ${isCtrlCmd}+D while on the page\n` +
                            `2. Or use your browser's bookmark button\n` +
                            `3. Choose folder: "${bookmarkFolder}"\n\n` +
                            `URL: ${fullUrl}\n\n` +
                            `This instruction will only show once per session.\n` +
                            `Would you like to open the page in a new tab to bookmark it?`;
                        
                        hasShownBookmarkInstructions = true;
                        
                        if (confirm(instructions)) {
                            window.open(fullUrl, '_blank');
                        }
                    } else {
                        // Just open the page without instructions
                        window.open(fullUrl, '_blank');
                    }
                }
                
                bookmarkedFiles.add(fileName);
                saveBookmarks();
                updateBookmarkButton(fileName);
                updateBookmarksCount();
                showStatus(`Added ${fileName} to bookmarks folder: ${bookmarkFolder}`, 'success');
                
            } catch (error) {
                console.error('Error adding bookmark:', error);
                showStatus('Failed to add bookmark - please add manually', 'error');
            }
        }

        function updateBookmarkButton(fileName) {
            const cards = document.querySelectorAll('.style-card');
            cards.forEach(card => {
                const cardFileName = card.dataset.fileName;
                if (cardFileName === fileName) {
                    const bookmarkBtn = card.querySelector('.bookmark-btn');
                    const icon = bookmarkBtn.querySelector('i');
                    
                    if (bookmarkedFiles.has(fileName)) {
                        bookmarkBtn.classList.add('bookmarked');
                        icon.className = 'fas fa-bookmark';
                    } else {
                        bookmarkBtn.classList.remove('bookmarked');
                        icon.className = 'far fa-bookmark';
                    }
                }
            });
        }

        function changeBookmarkFolder() {
            const newFolder = prompt(
                `Current bookmark folder: "${bookmarkFolder}"\n\n` +
                'Enter new folder name (or leave empty for default):',
                bookmarkFolder
            );
            
            if (newFolder !== null) {
                bookmarkFolder = newFolder || 'HTML Previewer';
                saveBookmarks();
                showStatus(`Bookmark folder changed to: ${bookmarkFolder}`, 'success');
            }
        }

        // Remove file from current view (NEVER affects favorites or bookmarks)
        function removeFileFromView(fileName) {
            if (confirm(`Remove "${fileName}" from current view?\n\nThis will not delete the file or affect your favorites/bookmarks.\nJust hides it from this session.`)) {
                allFiles = allFiles.filter(file => file.name !== fileName);
                displayedItems = 0;
                loadFiles();
                saveLastSession();
                
                // Check if file is favorited/bookmarked to inform user
                const isFavorited = favorites.has(fileName);
                const isBookmarked = bookmarkedFiles.has(fileName);
                let statusMsg = `Removed ${fileName} from view`;
                
                if (isFavorited && isBookmarked) {
                    statusMsg += ' (still in favorites & bookmarks)';
                } else if (isFavorited) {
                    statusMsg += ' (still in favorites)';
                } else if (isBookmarked) {
                    statusMsg += ' (still in bookmarks)';
                }
                
                showStatus(statusMsg, 'success');
            }
        }

        // Simplified delete functionality
        function deleteFile(fileName, filePath) {
            const deleteChoice = confirm(
                `üóëÔ∏è Delete "${fileName}"?\n\n` +
                `Choose your action:\n\n` +
                `‚Ä¢ Click OK: Open file location in Windows Explorer\n` +
                `‚Ä¢ Click Cancel: Just remove from this view\n\n` +
                `(The delete button will open the file location so you can delete it manually)`
            );
            
            if (deleteChoice) {
                // User chose OK - Open file location
                try {
                    // Get the current directory path
                    let currentDir = window.location.href;
                    
                    if (window.location.protocol === 'file:') {
                        // Convert file:// URL to Windows path
                        currentDir = currentDir.replace('file:///', '').replace(/\//g, '\\');
                        currentDir = currentDir.substring(0, currentDir.lastIndexOf('\\'));
                        
                        // Try to open Windows Explorer to the file location
                        const explorerCommand = `explorer.exe /select,"${currentDir}\\${fileName}"`;
                        
                        // Show user how to open the location
                        const instructions = 
                            `üìÅ Opening File Location\n\n` +
                            `I'll help you delete "${fileName}":\n\n` +
                            `1. Copy this path: ${currentDir}\n` +
                            `2. Open Windows Explorer (Win+E)\n` +
                            `3. Paste the path in address bar\n` +
                            `4. Find and delete "${fileName}"\n\n` +
                            `The file will be removed from this view now.\n\n` +
                            `Path copied to clipboard if possible.`;
                        
                        // Try to copy path to clipboard
                        if (navigator.clipboard) {
                            navigator.clipboard.writeText(currentDir).catch(() => {});
                        }
                        
                        alert(instructions);
                        
                    } else {
                        // For HTTP protocol
                        const serverPath = currentDir.substring(0, currentDir.lastIndexOf('/'));
                        const instructions = 
                            `üìÅ File Location Info\n\n` +
                            `Server URL: ${serverPath}\n` +
                            `File: ${fileName}\n\n` +
                            `To delete the file:\n` +
                            `1. Navigate to your server directory\n` +
                            `2. Find and delete "${fileName}"\n` +
                            `3. Refresh this page\n\n` +
                            `The file will be removed from this view now.`;
                        
                        alert(instructions);
                    }
                    
                } catch (error) {
                    console.warn('Could not determine file location:', error);
                    alert(`File location: Please look for "${fileName}" in your HTML files directory`);
                }
                
                showStatus(`Opened location for ${fileName} - please delete manually`, 'success');
            } else {
                // User chose Cancel - Just remove from view
                showStatus(`${fileName} removed from view only`, 'success');
            }
            
            // Always remove from view regardless of choice
            allFiles = allFiles.filter(file => file.name !== fileName);
            // DO NOT remove from favorites or bookmarks - only remove from current view
            // favorites.delete(fileName);  // REMOVED - favorites should persist
            // bookmarkedFiles.delete(fileName);  // REMOVED - bookmarks should persist
            
            // Only save session and refresh view
            saveLastSession();
            
            displayedItems = 0;
            loadFiles();
        }

        // Initialize the scanner
        document.addEventListener('DOMContentLoaded', function() {
            loadFavorites();
            loadBookmarks();
            loadUserPreferences();
            updateBookmarksCount(); // Initialize bookmark count display
            setupEventListeners();
            
            // Check if auto-scanning is disabled before trying to restore or scan
            if (localStorage.getItem('htmlPreviewer_preventAutoScan') === 'true') {
                console.log('üö´ Auto-scanning disabled. No session restoration or directory scanning.');
                showStatus('üö´ Auto-scanning disabled after Nuclear Reset. Click "Refresh Directory" to scan manually.', 'error');
                
                // Update the current path to show why no files are displayed
                document.getElementById('currentPath').textContent = 'üö´ Auto-scanning disabled - Click "Refresh Directory" to find files';
                
                showNoResults();
                return;
            }
            
            // Try to restore last session
            const sessionRestored = loadLastSession();
            
            if (sessionRestored && allFiles.length > 0) {
                // Session was restored, load the files
                displayedItems = 0;
                loadFiles();
            } else {
                // No session or empty session, scan directory normally
                scanDirectory();
                
                // Check for previous session when starting fresh (in case auto-restore failed)
                setTimeout(() => {
                    if (allFiles.length === 0) {
                        checkForPreviousSession();
                    }
                }, 2000);
            }
        });

        function setupEventListeners() {
            // Search functionality
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', debounce(handleSearch, 300));

            // Filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', handleFilter);
            });

            // Infinite scroll
            window.addEventListener('scroll', handleScroll);
        }

        function showStatus(message, type = 'scanning') {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            const icon = indicator.querySelector('i');
            
            text.textContent = message;
            indicator.className = `status-indicator show ${type}`;
            
            // Update icon based on type
            if (type === 'scanning') {
                icon.className = 'fas fa-spinner fa-spin text-blue-500';
            } else if (type === 'success') {
                icon.className = 'fas fa-check-circle text-green-500';
            } else if (type === 'error') {
                icon.className = 'fas fa-exclamation-circle text-red-500';
            }
            
            // Auto-hide success messages
            if (type === 'success') {
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 3000);
            }
        }

        async function scanDirectory() {
            // Check if auto-scanning is disabled
            if (preventAutoScanning || localStorage.getItem('htmlPreviewer_preventAutoScan') === 'true') {
                console.log('üö´ Auto-scanning disabled after reset. Use refreshFiles() to manually scan.');
                showStatus('Auto-scanning disabled. Click "Refresh Directory" to manually scan.', 'error');
                showNoResults();
                return;
            }
            
            showStatus('Scanning directory...', 'scanning');
            
            try {
                // Get current directory path
                const currentPath = window.location.pathname.replace(/[^/]*$/, '');
                document.getElementById('currentPath').textContent = currentPath || '/';
                
                // Discover HTML files using multiple methods
                const files = await discoverHTMLFiles();
                
                if (files.length === 0) {
                    showNoResults();
                    showStatus('No HTML files found', 'error');
                    return;
                }
                
                            allFiles = files;
            displayedItems = 0;
            
            showStatus(`Found ${files.length} HTML files`, 'success');
            loadFiles();
            saveLastSession(); // Save session after discovering files
                
            } catch (error) {
                console.error('Error scanning directory:', error);
                showError();
                showStatus('Scan failed', 'error');
            }
        }

        async function discoverHTMLFiles() {
            const files = [];
            
            // Initialize the universal tracker if not already done
            if (!universalTracker) {
                universalTracker = createUniversalDirectoryTracker();
                showStatus('üéØ Universal Directory Tracker initialized', 'success');
            }
            
            // Use the tracker to discover files with REAL paths
            showStatus('üîç Scanning directory with Universal Tracker...', 'scanning');
            const trackerFiles = await universalTracker.discoverLocalFiles();
            
            if (trackerFiles.length > 0) {
                files.push(...trackerFiles);
                showStatus(`üéâ Found ${trackerFiles.length} HTML files with REAL file:// URLs!`, 'success');
                
                // Update directory info with tracker details
                const directoryName = getCurrentDirectoryName() || 'Root';
                document.getElementById('currentPath').textContent = 
                    `üìÅ ${directoryName} - ${trackerFiles.length} files (Universal Tracker)`;
                
                return files.sort((a, b) => a.name.localeCompare(b.name));
            }
            
            // Fallback to original detection methods if tracker finds nothing
            console.log('üîÑ Tracker found no files, falling back to original methods...');
            
            // Check if we're running on file:// protocol
            const isFileProtocol = window.location.protocol === 'file:';
            
            if (isFileProtocol) {
                // For file:// protocol, we need to use a different approach
                showStatus('File protocol detected - using manual discovery mode', 'scanning');
                
                // Only check for the exact files we know exist in your directory
                const knownFiles = [
                    { name: 'Home.html', size: 145000, date: '2025-06-16' },
                    { name: 'Home - Copy.html', size: 134000, date: '2025-06-14' },
                    { name: 'create-a-self-contained-indexhtml-file-t-810.html', size: 8500, date: '2025-06-17' },
                    { name: 'file-cards-each-preview-in-a-white-card-824.html', size: 7200, date: '2025-06-17' }, 
                    { name: 'header-bar-clean-title-html-file-explore-162.html', size: 4800, date: '2025-06-17' },
                    { name: 'main-grid-responsive-masonry-layout-3-5-773.html', size: 9200, date: '2025-06-17' },
                    { name: '-1-modern-file-explorer-ui-389.html', size: 85000, date: '2025-06-17' },
                    { name: '-1-developer-focused-thumbnail-gallery-w-978.html', size: 120000, date: '2025-06-17' }
                ];
                
                let foundCount = 0;
                for (const fileInfo of knownFiles) {
                    if (fileInfo.name !== currentFileName) {
                        foundCount++;
                        // Use tracker to construct real URLs even for known files
                        const realUrl = universalTracker.getFileUrl(fileInfo.name);
                        files.push({
                            name: fileInfo.name,
                            path: realUrl,
                            originalPath: realUrl,
                            displayName: fileInfo.name.replace(/\.(html|htm)$/i, ''),
                            discovered: false,
                            lastModified: new Date(fileInfo.date),
                            size: fileInfo.size,
                            sizeFormatted: formatFileSize(fileInfo.size),
                            method: 'tracker-fallback',
                            realPathAvailable: true
                        });
                    }
                }
                
                showStatus(`üìã Showing ${foundCount} known HTML files with real URLs`, 'success');
                
                return files.sort((a, b) => a.name.localeCompare(b.name));
            }
            
            // Method 1: Try to fetch a directory listing (works with HTTP servers)
            try {
                const response = await fetch('./');
                if (response.ok) {
                    const html = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Look for directory listing links - ONLY files in current directory
                    const links = doc.querySelectorAll('a[href]');
                    for (const link of links) {
                        const href = link.getAttribute('href');
                        
                        // Only include files that:
                        // 1. End with .html or .htm
                        // 2. Are not this file
                        // 3. Don't start with http (external links)
                        // 4. Don't contain / (no subdirectories)
                        // 5. Don't contain .. (no parent directories)
                        if (href && 
                            (href.endsWith('.html') || href.endsWith('.htm')) && 
                            href !== currentFileName && 
                            !href.startsWith('http') && 
                            !href.includes('/') && 
                            !href.includes('..') &&
                            !href.includes('\\')) {
                            
                            const fileName = href;
                            const fileInfo = await getFileInfo(href);
                            files.push({
                                name: fileName,
                                path: href,
                                originalPath: href,
                                displayName: fileName.replace(/\.(html|htm)$/i, ''),
                                method: 'directory-listing',
                                ...fileInfo
                            });
                        }
                    }
                }
            } catch (e) {
                console.log('Directory listing not available:', e.message);
            }
            
            // Method 2: Try common filename patterns if no files found
            if (files.length === 0) {
                // Based on your directory, let's check for these specific files:
                const commonNames = [
                    // From your screenshot
                    'Home.html',
                    'create-a-self-contained-indexhtml-file-t-810.html',
                    'file-cards-each-preview-in-a-white-card-824.html', 
                    'header-bar-clean-title-html-file-explore-162.html',
                    'main-grid-responsive-masonry-layout-3-5-773.html',
                    '-1-modern-file-explorer-ui-389.html',
                    '-1-developer-focused-thumbnail-gallery-w-978.html',
                    'Home - Copy.html',
                    
                    // Common patterns
                    'index.html', 'index.htm',
                    'home.html', 'main.html', 'app.html', 'page.html',
                    'test.html', 'sample.html', 'template.html', 'layout.html',
                    'dashboard.html', 'landing.html', 'about.html', 'contact.html',
                    'portfolio.html', 'gallery.html', 'blog.html', 'shop.html'
                ];
                
                for (const fileName of commonNames) {
                    if (fileName !== currentFileName) {
                        try {
                            const response = await fetch(fileName, { method: 'HEAD' });
                            if (response.ok) {
                                const fileInfo = await getFileInfo(fileName);
                                files.push({
                                    name: fileName,
                                    path: fileName,
                                    originalPath: fileName,
                                    displayName: fileName.replace(/\.(html|htm)$/i, ''),
                                    discovered: true,
                                    method: 'pattern-matching',
                                    ...fileInfo
                                });
                            }
                        } catch (e) {
                            // File doesn't exist, continue
                        }
                    }
                }
            }
            
            return files.sort((a, b) => a.name.localeCompare(b.name));
        }

        async function getFileInfo(filePath) {
            try {
                const response = await fetch(filePath, { method: 'HEAD' });
                const lastModified = response.headers.get('last-modified');
                const contentLength = response.headers.get('content-length');
                
                return {
                    lastModified: lastModified ? new Date(lastModified) : new Date(),
                    size: contentLength ? parseInt(contentLength) : 0,
                    sizeFormatted: contentLength ? formatFileSize(parseInt(contentLength)) : 'Unknown'
                };
            } catch (e) {
                return {
                    lastModified: new Date(),
                    size: 0,
                    sizeFormatted: 'Unknown'
                };
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function formatDate(date) {
            if (!date) return 'Unknown';
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 1) return 'Today';
            if (diffDays === 2) return 'Yesterday';
            if (diffDays <= 7) return `${diffDays - 1} days ago`;
            
            return date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric', 
                year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined 
            });
        }

        function handleSearch(e) {
            currentSearch = e.target.value.toLowerCase();
            
            // Add to search history if not empty
            if (currentSearch.length > 1) {
                addToSearchHistory(currentSearch);
            }
            
            displayedItems = 0;
            loadFiles();
            saveLastSession(); // Save session when search changes
        }

        function handleFilter(e) {
            // Update active filter button
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
            
            currentFilter = e.target.dataset.filter;
            displayedItems = 0;
            loadFiles();
            saveLastSession(); // Save session when filter changes
            saveUserPreferences(); // Save preferences when filter changes
        }

        function loadFiles() {
            const grid = document.getElementById('filesGrid');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const noResults = document.getElementById('noResults');
            const errorMessage = document.getElementById('errorMessage');
            
            // Hide error message and no results
            errorMessage.classList.add('hidden');
            noResults.classList.add('hidden');
            
            // Show loading
            if (displayedItems === 0) {
                grid.innerHTML = '';
                loadingIndicator.classList.remove('hidden');
            }

            // Filter files
            let filteredFiles = allFiles.filter(file => {
                const matchesSearch = !currentSearch || 
                    file.name.toLowerCase().includes(currentSearch) ||
                    file.displayName.toLowerCase().includes(currentSearch);
                
                let matchesFilter = true;
                switch (currentFilter) {
                    case 'recent':
                        const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
                        matchesFilter = file.lastModified > dayAgo;
                        break;
                    case 'large':
                        matchesFilter = file.size > 50000; // > 50KB
                        break;
                    case 'small':
                        matchesFilter = file.size > 0 && file.size <= 10000; // <= 10KB
                        break;
                    case 'index':
                        matchesFilter = file.name.toLowerCase().includes('index') || 
                                      file.name.toLowerCase().includes('home') ||
                                      file.name.toLowerCase().includes('main');
                        break;
                    case 'favorites':
                        matchesFilter = favorites.has(file.name);
                        break;
                    case 'bookmarks':
                        matchesFilter = bookmarkedFiles.has(file.name);
                        break;
                    case 'tagged':
                        if (window.currentTagFilter) {
                            // Filter by specific tag
                            const fileTagSet = fileTags.get(file.name) || new Set();
                            matchesFilter = fileTagSet.has(window.currentTagFilter);
                        } else {
                            // Show all tagged files
                            matchesFilter = fileTags.has(file.name);
                        }
                        break;
                    case 'external':
                        matchesFilter = file.hasExternalDependencies === true;
                        break;
                    default: // 'all'
                        matchesFilter = true;
                }
                
                return matchesSearch && matchesFilter;
            });

            // Update results counter
            document.getElementById('resultCount').textContent = filteredFiles.length;
            
            // Update size info
            const totalSize = filteredFiles.reduce((sum, file) => sum + file.size, 0);
            document.getElementById('sizeInfo').textContent = 
                filteredFiles.length > 0 ? `Total size: ${formatFileSize(totalSize)}` : '';

            // Hide loading
            setTimeout(() => {
                loadingIndicator.classList.add('hidden');
                
                if (filteredFiles.length === 0) {
                    noResults.classList.remove('hidden');
                    return;
                }

                // Load items for this page
                const itemsToShow = filteredFiles.slice(displayedItems, displayedItems + itemsPerPage);
                
                if (displayedItems === 0) {
                    grid.innerHTML = '';
                }

                itemsToShow.forEach((file, index) => {
                    const fileCard = createFileCard(file);
                    fileCard.style.animationDelay = `${index * 0.1}s`;
                    grid.appendChild(fileCard);
                });

                displayedItems += itemsToShow.length;
            }, displayedItems === 0 ? 800 : 300);
        }

        async function processHtmlForPreview(htmlContent, filePath) {
            try {
                // Create a base URL for resolving relative paths
                const baseUrl = new URL(filePath, window.location.href);
                const basePath = baseUrl.href.substring(0, baseUrl.href.lastIndexOf('/') + 1);
                
                // Parse the HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                
                // Add base tag if not present (but be more aggressive about resolving paths)
                if (!doc.querySelector('base')) {
                    const baseTag = doc.createElement('base');
                    baseTag.href = basePath;
                    const head = doc.head || doc.getElementsByTagName('head')[0];
                    if (head) {
                        head.insertBefore(baseTag, head.firstChild);
                    }
                }
                
                // Try multiple base path strategies for better asset resolution
                const tryBasePaths = [
                    basePath,
                    basePath.replace(/\/[^\/]*\/$/, '/'), // Go up one directory
                    window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1) // Current page directory
                ];
                
                // Enhanced CSS link resolution
                const links = doc.querySelectorAll('link[rel="stylesheet"], link[href]');
                links.forEach(link => {
                    const href = link.getAttribute('href');
                    if (href && !href.startsWith('http') && !href.startsWith('//') && !href.startsWith('data:')) {
                        let resolved = false;
                        
                        // Try multiple base paths
                        for (const basePath of tryBasePaths) {
                            try {
                                const testUrl = new URL(href, basePath).href;
                                link.setAttribute('href', testUrl);
                                resolved = true;
                                break;
                            } catch (e) {
                                continue;
                            }
                        }
                        
                        if (!resolved) {
                            console.warn('Could not resolve CSS path:', href);
                            // Add fallback indicator
                            link.setAttribute('data-failed-resolution', href);
                        }
                    }
                });
                
                // Enhanced script source resolution
                const scripts = doc.querySelectorAll('script[src]');
                scripts.forEach(script => {
                    const src = script.getAttribute('src');
                    if (src && !src.startsWith('http') && !src.startsWith('//') && !src.startsWith('data:')) {
                        let resolved = false;
                        
                        for (const basePath of tryBasePaths) {
                            try {
                                const testUrl = new URL(src, basePath).href;
                                script.setAttribute('src', testUrl);
                                resolved = true;
                                break;
                            } catch (e) {
                                continue;
                            }
                        }
                        
                        if (!resolved) {
                            console.warn('Could not resolve JS path:', src);
                            script.setAttribute('data-failed-resolution', src);
                        }
                    }
                });
                
                // Enhanced image path resolution
                const images = doc.querySelectorAll('img[src]');
                images.forEach(img => {
                    const src = img.getAttribute('src');
                    if (src && !src.startsWith('http') && !src.startsWith('//') && !src.startsWith('data:')) {
                        let resolved = false;
                        
                        for (const basePath of tryBasePaths) {
                            try {
                                const testUrl = new URL(src, basePath).href;
                                img.setAttribute('src', testUrl);
                                resolved = true;
                                break;
                            } catch (e) {
                                continue;
                            }
                        }
                        
                        if (!resolved) {
                            console.warn('Could not resolve image path:', src);
                            img.setAttribute('data-failed-resolution', src);
                            // Add fallback placeholder
                            img.setAttribute('alt', `Missing image: ${src}`);
                            img.style.border = '1px dashed #ccc';
                            img.style.padding = '10px';
                            img.style.backgroundColor = '#f0f0f0';
                        }
                    }
                });
                
                // Enhanced error handling and fallback system for failed resources
                const errorHandlerScript = doc.createElement('script');
                errorHandlerScript.textContent = `
                    let failedResources = [];
                    let hasShownIndicator = false;
                    
                    // Enhanced CSS load error handling with fallbacks
                    document.querySelectorAll('link[rel="stylesheet"]').forEach((link, index) => {
                        // Set timeout for slow loading CSS
                        const timeoutId = setTimeout(() => {
                            console.warn('CSS load timeout:', link.href);
                            handleFailedResource('CSS', link.href);
                        }, 5000);
                        
                        link.onload = function() {
                            clearTimeout(timeoutId);
                        };
                        
                        link.onerror = function() {
                            clearTimeout(timeoutId);
                            console.warn('Failed to load CSS:', this.href);
                            handleFailedResource('CSS', this.href);
                            
                            // Try fallback paths
                            const originalHref = this.href;
                            const fallbackPaths = [
                                originalHref.replace(/^.*\\/([^\/]+)$/, './assets/$1'),
                                originalHref.replace(/^.*\\/([^\/]+)$/, '../assets/$1'),
                                originalHref.replace(/^.*\\/([^\/]+)$/, './$1')
                            ];
                            
                            this.remove(); // Remove failed link
                            
                            // Try fallback paths sequentially
                            let fallbackIndex = 0;
                            const tryFallback = () => {
                                if (fallbackIndex < fallbackPaths.length) {
                                    const fallbackLink = document.createElement('link');
                                    fallbackLink.rel = 'stylesheet';
                                    fallbackLink.href = fallbackPaths[fallbackIndex];
                                    fallbackLink.onload = () => console.log('CSS fallback successful:', fallbackPaths[fallbackIndex]);
                                    fallbackLink.onerror = () => {
                                        fallbackIndex++;
                                        tryFallback();
                                    };
                                    document.head.appendChild(fallbackLink);
                                }
                            };
                            tryFallback();
                        };
                    });
                    
                    // Enhanced script load error handling with fallbacks
                    document.querySelectorAll('script[src]').forEach(script => {
                        const timeoutId = setTimeout(() => {
                            console.warn('Script load timeout:', script.src);
                            handleFailedResource('JS', script.src);
                        }, 5000);
                        
                        script.onload = function() {
                            clearTimeout(timeoutId);
                        };
                        
                        script.onerror = function() {
                            clearTimeout(timeoutId);
                            console.warn('Failed to load script:', this.src);
                            handleFailedResource('JS', this.src);
                            
                            // Try fallback paths for JS
                            const originalSrc = this.src;
                            const fallbackPaths = [
                                originalSrc.replace(/^.*\\/([^\/]+)$/, './js/$1'),
                                originalSrc.replace(/^.*\\/([^\/]+)$/, '../js/$1'),
                                originalSrc.replace(/^.*\\/([^\/]+)$/, './assets/js/$1'),
                                originalSrc.replace(/^.*\\/([^\/]+)$/, './$1')
                            ];
                            
                            let fallbackIndex = 0;
                            const tryScriptFallback = () => {
                                if (fallbackIndex < fallbackPaths.length) {
                                    const fallbackScript = document.createElement('script');
                                    fallbackScript.src = fallbackPaths[fallbackIndex];
                                    fallbackScript.onload = () => console.log('JS fallback successful:', fallbackPaths[fallbackIndex]);
                                    fallbackScript.onerror = () => {
                                        fallbackIndex++;
                                        tryScriptFallback();
                                    };
                                    document.head.appendChild(fallbackScript);
                                }
                            };
                            tryScriptFallback();
                        };
                    });
                    
                    // Enhanced image error handling
                    document.querySelectorAll('img').forEach(img => {
                        img.onerror = function() {
                            console.warn('Failed to load image:', this.src);
                            this.style.cssText = 'border:2px dashed #ddd;padding:20px;background:#f9f9f9;color:#666;text-align:center;font-family:Arial;font-size:12px;min-height:100px;display:flex;align-items:center;justify-content:center;';
                            this.innerHTML = 'üñºÔ∏è Image not found: ' + (this.alt || this.src.split('/').pop());
                            this.removeAttribute('src');
                        };
                    });
                    
                    function handleFailedResource(type, url) {
                        failedResources.push({type, url, timestamp: Date.now()});
                        
                        if (!hasShownIndicator && failedResources.length > 0) {
                            const indicator = document.createElement('div');
                            indicator.id = 'resource-error-indicator';
                            indicator.style.cssText = 'position:fixed;top:10px;right:10px;background:#ff6b6b;color:white;padding:8px 12px;font-size:12px;z-index:9999;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,0.15);cursor:pointer;transition:all 0.3s;';
                            indicator.innerHTML = '‚ö†Ô∏è ' + failedResources.length + ' resource(s) failed to load';
                            indicator.title = 'Click to see details';
                            
                            indicator.onclick = function() {
                                const details = failedResources.map(r => '‚Ä¢ ' + r.type + ': ' + r.url.split('/').pop()).join('\\n');
                                alert('Failed Resources:\\n\\n' + details + '\\n\\nThis is normal for previews. The original file may work correctly.');
                                this.style.background = '#28a745';
                                this.innerHTML = '‚úì Acknowledged';
                                setTimeout(() => this.remove(), 2000);
                            };
                            
                            document.body.appendChild(indicator);
                            hasShownIndicator = true;
                            
                            // Auto-hide after 10 seconds
                            setTimeout(() => {
                                if (indicator.parentNode) {
                                    indicator.style.opacity = '0.7';
                                    indicator.innerHTML = '‚ö†Ô∏è Resources failed (click for details)';
                                }
                            }, 10000);
                        }
                    }
                `;
                doc.head.appendChild(errorHandlerScript);
                
                return {
                    processedHtml: doc.documentElement.outerHTML,
                    hasExternalDependencies: links.length > 0 || scripts.length > 0 || images.length > 0
                };
                
            } catch (error) {
                console.warn('Error processing HTML for preview:', error);
                return {
                    processedHtml: htmlContent,
                    hasExternalDependencies: false
                };
            }
        }

        function createFileCard(file) {
            const card = document.createElement('div');
            let cardClass = 'style-card rounded-2xl shadow-lg overflow-hidden cursor-pointer fade-in';
            
            // Special styling for tracker network files
            if (file.method === 'tracker-network') {
                cardClass += ' border-2 border-cyan-300';
            } else if (file.method === 'remote-tracker') {
                cardClass += ' border-2 border-purple-300';
            }
            
            card.className = cardClass;
            card.style.height = '420px';
            card.dataset.fileName = file.name;
            
            // Generate tags based on file properties
            const tags = [];
            if (file.name.toLowerCase().includes('index')) tags.push('index');
            if (file.size > 50000) tags.push('large');
            if (file.size <= 10000 && file.size > 0) tags.push('small');
            if (file.discovered) tags.push('auto-discovered');
            if (file.hasExternalDependencies) tags.push('external-deps');
            
            // Add path type indicator
            if (file.method === 'saved-absolute-path') {
                tags.push('saved-absolute-path');
            } else if (file.method === 'tracker-discovered' || 
                file.method === 'tracker-directory-listing' || 
                file.method === 'tracker-fallback' || 
                file.realPathAvailable) {
                tags.push('tracker-real-path');
            } else if (file.method === 'file-system-access') {
                tags.push('modern-api');
            } else if (file.method === 'folder-browse' || file.method === 'folder-real-path') {
                tags.push('blob-url');
            } else {
                const realFilePath = constructRealFilePath(file);
                if (realFilePath) {
                    tags.push('real-path');
                } else {
                    tags.push('blob-url');
                }
            }
            
            const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
            if (file.lastModified > dayAgo) tags.push('recent');
            
            const tagsHtml = tags.slice(0, 3).map(tag => {
                let tagClass = 'tag';
                let tagText = tag;
                
                if (tag === 'external-deps') {
                    tagClass = 'tag external-deps';
                    tagText = 'has external files';
                } else if (tag === 'saved-absolute-path') {
                    tagClass = 'tag saved-absolute-path';
                    tagText = 'SAVED absolute path';
                } else if (tag === 'tracker-real-path') {
                    tagClass = 'tag tracker-real-path';
                    tagText = 'real file:// URL';
                } else if (tag === 'real-path') {
                    tagClass = 'tag real-path';
                    tagText = 'real file:// URL';
                } else if (tag === 'modern-api') {
                    tagClass = 'tag modern-api';
                    tagText = 'File System API (blob)';
                } else if (tag === 'blob-url') {
                    tagClass = 'tag blob-url';
                    tagText = 'secure blob URL';
                }
                
                return `<span class="${tagClass} px-2 py-1 rounded-full text-xs font-medium">${tagText}</span>`;
            }).join('');

            const isCurrentlyFavorited = favorites.has(file.name);
            const heartIcon = isCurrentlyFavorited ? 'fas fa-heart' : 'far fa-heart';
            const favoritedClass = isCurrentlyFavorited ? 'favorited' : '';

            const isCurrentlyBookmarked = bookmarkedFiles.has(file.name);
            const bookmarkIcon = isCurrentlyBookmarked ? 'fas fa-bookmark' : 'far fa-bookmark';
            const bookmarkedClass = isCurrentlyBookmarked ? 'bookmarked' : '';

            card.innerHTML = `
                <div class="thumbnail relative" style="height: 70%;">
                    <div class="action-btn favorite-btn ${favoritedClass}" title="${isCurrentlyFavorited ? 'Remove from favorites' : 'Add to favorites'}">
                        <i class="${heartIcon}"></i>
                    </div>
                    <div class="action-btn bookmark-btn ${bookmarkedClass}" title="${isCurrentlyBookmarked ? 'Remove bookmark' : 'Add to bookmarks'}">
                        <i class="${bookmarkIcon}"></i>
                    </div>
                    <div class="action-btn folder-btn" title="Open file location in Explorer/Finder">
                        <i class="fas fa-folder-open"></i>
                    </div>
                    <div class="action-btn tag-btn" title="Add/edit tags for this file">
                        <i class="fas fa-tag"></i>
                    </div>
                    <div class="action-btn remove-btn" title="Remove from current view">
                        <i class="fas fa-times"></i>
                    </div>
                    <div class="action-btn delete-btn" title="Delete file: OK=Open location, Cancel=Remove from view">
                        <i class="fas fa-trash"></i>
                    </div>
                    
                    <!-- Selection Checkbox (hidden by default) -->
                    <div class="selection-checkbox" style="display: none;">
                        <input type="checkbox" class="file-checkbox" data-filename="${file.name}">
                    </div>
                    <div class="thumbnail-loading">
                        <i class="fas fa-spinner fa-spin text-2xl mb-2"></i>
                        <p class="text-xs">Loading preview...</p>
                    </div>
                    <iframe src="${file.path}" loading="lazy" sandbox="allow-scripts allow-same-origin"></iframe>
                    <div class="thumbnail-overlay">
                        <div class="flex justify-between items-center">
                            <span class="font-medium">${file.displayName}</span>
                            <span class="text-xs opacity-75">${file.sizeFormatted}</span>
                        </div>
                    </div>
                </div>
                <div class="p-4" style="height: 30%;">
                    <h3 class="text-lg font-bold text-gray-800 mb-1 truncate">${file.displayName}</h3>
                    <div class="file-info">
                        <div class="flex justify-between items-center text-sm text-gray-600">
                            <span><i class="fas fa-hdd mr-1"></i>${file.sizeFormatted}</span>
                            <span><i class="fas fa-calendar mr-1"></i>${formatDate(file.lastModified)}</span>
                        </div>
                        ${(file.method === 'folder-browse' || file.method === 'file-add') && file.folderPath ? 
                            `<div class="text-xs text-blue-600 mt-1 truncate" title="${file.fullPath}">
                                <i class="fas fa-folder mr-1"></i>${file.folderPath}
                            </div>` : ''}
                        ${file.method === 'tracker-network' ? 
                            `<div class="text-xs text-cyan-600 mt-1">
                                <i class="fas fa-radar-alt mr-1"></i>Network Tracker ‚Ä¢ Click to open
                            </div>` : ''}
                        ${file.method === 'remote-tracker' ? 
                            `<div class="text-xs text-purple-600 mt-1">
                                <i class="fas fa-satellite-dish mr-1"></i>From: ${file.trackerSource}
                            </div>` : ''}
                    </div>
                    <div class="flex flex-wrap gap-1 mt-2">
                        ${tagsHtml}
                    </div>
                </div>
            `;

            // Add click handler for the card
            card.addEventListener('click', (e) => {
                // Don't open file if clicking on action buttons or checkboxes
                if (!e.target.closest('.action-btn') && !e.target.closest('.selection-checkbox')) {
                    openFile(file);
                }
            });

            // Add action button click handlers
            const favoriteBtn = card.querySelector('.favorite-btn');
            favoriteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFavorite(file.name);
            });

            const bookmarkBtn = card.querySelector('.bookmark-btn');
            bookmarkBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleBookmark(file.name, file.path, file.originalPath);
            });

            // Add folder button click handler
            const folderBtn = card.querySelector('.folder-btn');
            if (folderBtn) {
                folderBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openFileLocation(file);
                });
            }

            // Add tag button click handler
            const tagBtn = card.querySelector('.tag-btn');
            if (tagBtn) {
                tagBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showTagDialog(file.name);
                });
            }

            // Add selection checkbox handler with enhanced click protection
            const checkbox = card.querySelector('.file-checkbox');
            const checkboxContainer = card.querySelector('.selection-checkbox');
            if (checkbox && checkboxContainer) {
                // Prevent checkbox clicks from bubbling up to card
                checkboxContainer.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                });
                
                checkbox.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    // Toggle the checkbox manually
                    checkbox.checked = !checkbox.checked;
                    // Trigger the selection
                    handleFileSelection(file.name, checkbox.checked);
                });
                
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    handleFileSelection(file.name, e.target.checked);
                });
            }

            const removeBtn = card.querySelector('.remove-btn');
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeFileFromView(file.name);
            });

            const deleteBtn = card.querySelector('.delete-btn');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Check if Ctrl key is held - if so, just remove from view
                if (e.ctrlKey) {
                    removeFileFromView(file.name);
                } else {
                    deleteFile(file.name, file.path);
                }
            });

            // Enhanced iframe loading with performance monitoring and memory management
            const iframe = card.querySelector('iframe');
            const loadingDiv = card.querySelector('.thumbnail-loading');
            
            // Performance monitoring
            const loadStartTime = performance.now();
            
            // Load and process the HTML file
            async function loadEnhancedPreview() {
                try {
                    if (file.file && file.file instanceof File) {
                        // For files loaded via file input
                        const htmlContent = await file.file.text();
                        const result = await processHtmlForPreview(htmlContent, file.name);
                        file.hasExternalDependencies = result.hasExternalDependencies;
                        const blob = new Blob([result.processedHtml], { type: 'text/html' });
                        const blobUrl = URL.createObjectURL(blob);
                        // Use blob URL only for iframe preview, keep original path for opening
                        iframe.src = blobUrl;
                    } else {
                        // For regular file paths, try to load and process
                        try {
                            // Preserve the original path before any processing
                            if (!file.originalPath) {
                                file.originalPath = file.path;
                            }
                            
                            const response = await fetch(file.path);
                            if (response.ok) {
                                const htmlContent = await response.text();
                                const result = await processHtmlForPreview(htmlContent, file.path);
                                file.hasExternalDependencies = result.hasExternalDependencies;
                                const blob = new Blob([result.processedHtml], { type: 'text/html' });
                                const blobUrl = URL.createObjectURL(blob);
                                // Use blob URL only for iframe preview, keep original path for opening
                                iframe.src = blobUrl;
                            } else {
                                throw new Error('Failed to fetch HTML content');
                            }
                        } catch (fetchError) {
                            console.warn('Could not fetch and process HTML, falling back to direct load:', fetchError);
                            // Fallback to direct loading with original path
                            iframe.src = file.originalPath || file.path;
                        }
                    }
                } catch (error) {
                    console.error('Error loading enhanced preview:', error);
                    // Fallback to direct loading with original path
                    iframe.src = file.originalPath || file.path;
                }
            }
            
            iframe.addEventListener('load', function() {
                this.classList.add('loaded');
                loadingDiv.style.display = 'none';
                
                // Performance tracking
                const loadTime = performance.now() - loadStartTime;
                console.log(`üìä ${file.name} loaded in ${loadTime.toFixed(0)}ms`);
                
                // Memory monitoring (if available)
                if (performance.memory) {
                    const memUsed = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                    if (memUsed > 100) { // Alert if over 100MB
                        console.warn(`‚ö†Ô∏è High memory usage: ${memUsed}MB`);
                    }
                }
                
                // Lazy cleanup of blob URLs after iframe loads
                if (this.src.startsWith('blob:')) {
                    setTimeout(() => {
                        try {
                            URL.revokeObjectURL(this.src);
                        } catch (e) {
                            // URL already revoked or invalid
                        }
                    }, 30000); // Cleanup after 30 seconds
                }
            });
            
            iframe.addEventListener('error', function() {
                const loadTime = performance.now() - loadStartTime;
                console.warn(`‚ùå ${file.name} failed to load after ${loadTime.toFixed(0)}ms`);
                
                loadingDiv.innerHTML = `
                    <div class="thumbnail-error">
                        <i class="fas fa-exclamation-triangle text-2xl mb-2"></i>
                        <p class="text-xs">Preview unavailable</p>
                        <p class="text-xs mt-1">External resources may not load</p>
                        <p class="text-xs mt-1 opacity-75">Failed in ${loadTime.toFixed(0)}ms</p>
                    </div>
                `;
                
                // Cleanup failed blob URLs immediately
                if (this.src.startsWith('blob:')) {
                    try {
                        URL.revokeObjectURL(this.src);
                    } catch (e) {
                        // URL already revoked or invalid
                    }
                }
            });
            
            // Start loading the enhanced preview
            loadEnhancedPreview();

            return card;
        }

        function openFile(file) {
            // Special handling for tracker network files
            if (file.method === 'tracker-network') {
                // Open the tracker itself
                console.log(`üï∏Ô∏è Opening tracker: ${file.url}`);
                window.open(file.url, '_blank');
                showStatus(`üï∏Ô∏è Opened ${file.folderName} tracker`, 'success');
                return;
            }
            
            if (file.method === 'remote-tracker') {
                // Scan the tracker directory first, then open the file
                console.log(`üì° Opening remote file: ${file.path}`);
                window.open(file.path, '_blank');
                showStatus(`üì° Opened ${file.displayName} from ${file.trackerSource}`, 'success');
                return;
            }
            
            // PRIORITY 0: Check for custom path mapping FIRST - OVERRIDES SAVED PATHS
            const customPathMapping = localStorage.getItem('htmlPreviewer_customPathMapping');
            if (customPathMapping) {
                try {
                    const pathConfig = JSON.parse(customPathMapping);
                    if (pathConfig.enabled && pathConfig.basePath) {
                        // Ensure proper path construction
                        let customUrl = pathConfig.basePath;
                        if (!customUrl.endsWith('/')) {
                            customUrl += '/';
                        }
                        customUrl += file.name;
                        
                        console.log(`üéØ OPENFILE: Using custom path mapping for ${file.name}:`);
                        console.log(`   Base path: ${pathConfig.basePath}`);
                        console.log(`   Final URL: ${customUrl}`);
                        
                        window.open(customUrl, '_blank');
                        showStatus(`üéØ Opened with CUSTOM path mapping: ${file.name}`, 'success');
                        return;
                    }
                } catch (e) {
                    console.warn('Invalid custom path mapping in openFile:', e);
                }
            }

            // PRIORITY 1: Check saved absolute paths (but only if no custom mapping)
            const savedAbsolutePath = getAbsoluteFilePath(file.name);
            if (savedAbsolutePath) {
                try {
                    console.log(`üíæ Using saved absolute path: ${savedAbsolutePath}`);
                    
                    // Validate the path before attempting to open
                    if (savedAbsolutePath.startsWith('file://') || savedAbsolutePath.startsWith('http')) {
                        window.open(savedAbsolutePath, '_blank');
                        showStatus(`üöÄ Opened with SAVED absolute path: ${file.name}`, 'success');
                        
                        // Add to recent files
                        addToRecentFiles({
                            ...file,
                            path: savedAbsolutePath,
                            originalPath: savedAbsolutePath
                        });
                        
                        return;
                    } else {
                        console.warn('‚ùå Invalid saved path format:', savedAbsolutePath);
                    }
                } catch (error) {
                    console.warn('‚ùå Saved absolute path failed, trying other methods:', error);
                    showStatus(`‚ö†Ô∏è Saved path failed, trying backup methods: ${file.name}`, 'error');
                }
            }
            
            // Priority 1: Files discovered by Universal Tracker (guaranteed real paths)
            if (file.method === 'tracker-discovered' || 
                file.method === 'tracker-directory-listing' || 
                file.method === 'tracker-fallback' || 
                file.realPathAvailable) {
                
                const realPath = file.path;
                console.log(`üéØ Opening with GUARANTEED real path: ${realPath}`);
                
                try {
                    window.open(realPath, '_blank');
                    showStatus(`üöÄ Opened with REAL file:// URL: ${file.name}`, 'success');
                    console.log(`‚úÖ Successfully opened: ${realPath}`);
                    return;
                } catch (error) {
                    console.error('‚ùå Failed to open real path:', error);
                    showStatus(`‚ùå Real path failed: ${file.name}`, 'error');
                }
            }
            
            // Priority 2: Try to construct a real file path for other files
            const constructedPath = constructRealFilePath(file);
            
            if (constructedPath) {
                try {
                    window.open(constructedPath, '_blank');
                    showStatus(`üîß Opened with constructed path: ${file.name}`, 'success');
                    console.log(`‚úÖ Opened with constructed path: ${constructedPath}`);
                    return;
                } catch (error) {
                    console.warn('‚ùå Constructed path failed, falling back to blob URL:', error);
                }
            }
            
            // Priority 3: Fallback to blob URLs for user-selected files
            if (file.method === 'folder-browse' || file.method === 'file-add') {
                openFileDirectly(file);
                const pathType = file.file?.webkitRelativePath ? 'external folder' : 'file selection';
                showStatus(`üìé Opened with blob URL: ${file.name} (from ${pathType})`, 'success');
                return;
            }
            
            // Priority 4: Last resort
            showStatus('‚ùå Cannot determine file location', 'error');
            console.error('No viable path found for file:', file);
        }

                function constructRealFilePath(file) {
            // PRIORITY 1: Check for custom path mapping first
            const customPathMapping = localStorage.getItem('htmlPreviewer_customPathMapping');
            if (customPathMapping) {
                try {
                    const pathConfig = JSON.parse(customPathMapping);
                    if (pathConfig.enabled && pathConfig.basePath) {
                        let customUrl = pathConfig.basePath;
                        if (!customUrl.endsWith('/')) {
                            customUrl += '/';
                        }
                        customUrl += file.name;
                        
                        console.log(`üéØ CONSTRUCT PATH: Using custom mapping for ${file.name}:`);
                        console.log(`   Base path: ${pathConfig.basePath}`);
                        console.log(`   Final URL: ${customUrl}`);
                        return customUrl;
                    }
                } catch (e) {
                    console.warn('Invalid custom path mapping in constructRealFilePath:', e);
                }
            }
            
            // PRIORITY 2: Use the file's own path information if available
            if (file.path && file.path.startsWith('file://')) {
                console.log(`üéØ CONSTRUCT PATH: Using file's own path for ${file.name}: ${file.path}`);
                return file.path;
            }
            
            // PRIORITY 3: Use original path if available
            if (file.originalPath && file.originalPath.startsWith('file://')) {
                console.log(`üéØ CONSTRUCT PATH: Using original path for ${file.name}: ${file.originalPath}`);
                return file.originalPath;
            }
            
            // PRIORITY 4: Try to construct from webkitRelativePath if available
            if (file.file && file.file.webkitRelativePath) {
                const relativePath = file.file.webkitRelativePath;
                console.log(`üéØ CONSTRUCT PATH: File has webkitRelativePath: ${relativePath}`);
                
                if (window.location.protocol === 'file:') {
                    const currentPath = decodeURIComponent(window.location.pathname);
                    const currentDirPath = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
                    
                    // Extract the folder name from webkitRelativePath
                    const pathParts = relativePath.split('/');
                    if (pathParts.length > 1) {
                        // File is in a subfolder - construct path to parent + relative path
                        const parentPath = currentDirPath.substring(0, currentDirPath.lastIndexOf('/', currentDirPath.length - 2) + 1);
                        const fullPath = parentPath + relativePath;
                        const fileUrl = 'file://' + fullPath.replace(/\\/g, '/');
                        console.log(`üéØ CONSTRUCT PATH: Using webkit relative path: ${fileUrl}`);
                        return fileUrl;
                    }
                }
            }
            
            // FALLBACK: Use current directory + filename
            const currentUrl = window.location.href;
            const currentDir = currentUrl.substring(0, currentUrl.lastIndexOf('/') + 1);
            const fallbackUrl = currentDir + file.name;
            console.log(`üéØ CONSTRUCT PATH: Using fallback path for ${file.name}: ${fallbackUrl}`);
            return fallbackUrl;
        }



        function openFileDirectly(file) {
            if (file.file && file.file instanceof File) {
                try {
                    // Create a fresh blob URL for opening
                    const blobUrl = URL.createObjectURL(file.file);
                    window.open(blobUrl, '_blank');
                    showStatus(`üìé Opened ${file.name} with secure blob URL`, 'success');
                    
                    // Store this working blob URL for future use
                    file.workingBlobUrl = blobUrl;
                    
                    // Add to recent files with working URL
                    addToRecentFiles({
                        ...file,
                        path: blobUrl,
                        originalPath: blobUrl
                    });
                    
                    // Clean up the blob URL after a longer delay to ensure it works
                    setTimeout(() => {
                        URL.revokeObjectURL(blobUrl);
                    }, 30000); // 30 seconds instead of 10
                } catch (error) {
                    console.warn('Could not open file, trying download:', error);
                    showStatus(`‚ö†Ô∏è Could not open ${file.name}, trying download`, 'error');
                    downloadFile(file);
                }
            } else {
                // Fallback to existing blob URL or try to recreate it
                if (file.path && file.path.startsWith('blob:')) {
                    try {
                        window.open(file.path, '_blank');
                        showStatus(`üìé Opened ${file.name} with existing blob URL`, 'success');
                    } catch (error) {
                        console.warn('Existing blob URL failed:', error);
                        showStatus(`‚ùå Blob URL expired for ${file.name}`, 'error');
                        downloadFile(file);
                    }
                } else {
                    showStatus(`‚ùå No valid path available for ${file.name}`, 'error');
                    downloadFile(file);
                }
            }
        }

        function copyFolderPath(file) {
            const folderPath = file.folderPath;
            const fullPath = file.fullPath;
            
            // Determine what path to copy
            let pathToCopy = '';
            
            if (folderPath && folderPath !== 'Unknown location' && folderPath !== 'Individual file selection') {
                pathToCopy = folderPath;
            } else if (fullPath && fullPath !== file.name) {
                // Extract folder from full path
                const pathParts = fullPath.split('/');
                if (pathParts.length > 1) {
                    pathParts.pop(); // Remove filename
                    pathToCopy = pathParts.join('/');
                }
            }
            
            if (pathToCopy) {
                // Copy to clipboard
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(pathToCopy).then(() => {
                        showStatus(`üìÅ Folder path copied: ${pathToCopy}`, 'success');
                    }).catch(() => {
                        // Fallback for older browsers
                        showStatus(`üìÅ Folder path: ${pathToCopy}`, 'success');
                    });
                } else {
                    // Fallback for browsers without clipboard API
                    showStatus(`üìÅ Folder path: ${pathToCopy}`, 'success');
                }
            } else {
                showStatus('üìÅ Folder path not available', 'error');
            }
        }

        function downloadFile(file) {
            const pathToDownload = file.path; // Use the blob URL for download
            const link = document.createElement('a');
            link.href = pathToDownload;
            link.download = file.name;
            link.target = '_blank';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showStatus(`Downloaded ${file.name}`, 'success');
        }

        function showNoResults() {
            document.getElementById('loadingIndicator').classList.add('hidden');
            document.getElementById('noResults').classList.remove('hidden');
            document.getElementById('errorMessage').classList.add('hidden');
            
            // Check if auto-scanning is disabled and update the message accordingly
            const isAutoScanDisabled = localStorage.getItem('htmlPreviewer_preventAutoScan') === 'true';
            const noResultsDiv = document.getElementById('noResults');
            const titleElement = noResultsDiv.querySelector('h3');
            const descElement = noResultsDiv.querySelector('p');
            const iconElement = noResultsDiv.querySelector('i');
            
            if (isAutoScanDisabled) {
                // Show auto-scan disabled message
                iconElement.className = 'fas fa-ban text-6xl text-red-500';
                titleElement.textContent = 'Auto-scanning disabled';
                titleElement.className = 'text-2xl font-bold text-red-600 mb-4';
                descElement.innerHTML = 'Files were cleared using Nuclear Reset. Auto-discovery is disabled to prevent unwanted files from reappearing.<br><br><strong>Click "Refresh Directory" to manually scan for files when ready.</strong>';
                descElement.className = 'text-gray-700 mb-6';
                
                // Update the parent div styling
                noResultsDiv.className = 'text-center py-20 bg-red-50 border-2 border-red-200 rounded-lg mx-4';
            } else {
                // Show normal no files message
                iconElement.className = 'fas fa-file-code text-6xl text-gray-400';
                titleElement.textContent = 'No HTML files found';
                titleElement.className = 'text-2xl font-bold text-gray-600 mb-4';
                descElement.textContent = 'Place some HTML files in this directory to preview them';
                descElement.className = 'text-gray-500 mb-6';
                
                // Reset the parent div styling
                noResultsDiv.className = 'text-center py-20';
            }
        }

        function showError() {
            document.getElementById('loadingIndicator').classList.add('hidden');
            document.getElementById('noResults').classList.add('hidden');
            document.getElementById('errorMessage').classList.remove('hidden');
        }

        function refreshFiles() {
            showStatus('Refreshing...', 'scanning');
            
            // Clear auto-scan prevention flags for manual refresh
            preventAutoScanning = false;
            localStorage.removeItem('htmlPreviewer_preventAutoScan');
            
            allFiles = [];
            displayedItems = 0;
            
            // Reset UI
            document.getElementById('filesGrid').innerHTML = '';
            document.getElementById('loadingIndicator').classList.remove('hidden');
            document.getElementById('noResults').classList.add('hidden');
            document.getElementById('errorMessage').classList.add('hidden');
            
            // Scan again (now allowed since we cleared the prevention flags)
            setTimeout(() => {
                scanDirectory();
            }, 500);
        }

        function resetAllPreviews() {
            // Clear all files and reset to initial state
            allFiles = [];
            isShowingFolderFiles = false;
            window.selectedFolderFiles = null;
            window.lastDirectoryHandle = null;
            displayedItems = 0;
            currentSearch = '';
            currentFilter = 'all';
            
            // Clear any selection state
            selectedFiles.clear();
            
            // Clear the grid
            const grid = document.getElementById('filesGrid');
            grid.innerHTML = '';
            
            // Hide loading and error states
            document.getElementById('loadingIndicator').classList.add('hidden');
            document.getElementById('noResults').classList.add('hidden');
            document.getElementById('errorMessage').classList.add('hidden');
            document.getElementById('scanControls').classList.add('hidden');
            
            // Reset search input
            const searchInput = document.getElementById('searchInput');
            if (searchInput) searchInput.value = '';
            
            // Reset filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.filter === 'all') {
                    btn.classList.add('active');
                }
            });
            
            // Reset file input
            const folderInput = document.getElementById('folderInput');
            if (folderInput) folderInput.value = '';
            
            // Reset directory info
            document.getElementById('currentPath').textContent = 'Current directory (no files loaded)';
            
            // Reset counters
            document.getElementById('resultCount').textContent = '0';
            document.getElementById('sizeInfo').textContent = '';
            
            // Reset button states
            updateFolderButtons();
            
            // Update favorites count
            updateFavoritesCount();
            
            // Clear any bulk selection UI
            exitSelectionMode();
            
            // Save empty session to prevent restoration
            saveLastSession();
            
            // Also clear the last session from storage to prevent auto-restoration
            localStorage.removeItem(LAST_SESSION_KEY);
            
            // Show status
            showStatus('All previews cleared successfully - session will not auto-restore', 'success');
            
            // After a short delay, show the no results state
            setTimeout(() => {
                showNoResults();
            }, 500);
        }

        function handleScroll() {
            if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 1000) {
                const filteredFiles = getFilteredFiles();
                if (displayedItems < filteredFiles.length) {
                    loadFiles();
                }
            }
        }

        function getFilteredFiles() {
            return allFiles.filter(file => {
                const matchesSearch = !currentSearch || 
                    file.name.toLowerCase().includes(currentSearch) ||
                    file.displayName.toLowerCase().includes(currentSearch);
                
                let matchesFilter = true;
                switch (currentFilter) {
                    case 'recent':
                        const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
                        matchesFilter = file.lastModified > dayAgo;
                        break;
                    case 'large':
                        matchesFilter = file.size > 50000;
                        break;
                    case 'small':
                        matchesFilter = file.size > 0 && file.size <= 10000;
                        break;
                    case 'index':
                        matchesFilter = file.name.toLowerCase().includes('index') || 
                                      file.name.toLowerCase().includes('home') ||
                                      file.name.toLowerCase().includes('main');
                        break;
                    case 'favorites':
                        matchesFilter = favorites.has(file.name);
                        break;
                    case 'bookmarks':
                        matchesFilter = bookmarkedFiles.has(file.name);
                        break;
                    case 'external':
                        matchesFilter = file.hasExternalDependencies === true;
                        break;
                    default:
                        matchesFilter = true;
                }
                
                return matchesSearch && matchesFilter;
            });
        }

        function clearFilters() {
            currentFilter = 'all';
            currentSearch = '';
            displayedItems = 0;
            
            document.getElementById('searchInput').value = '';
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('[data-filter="all"]').classList.add('active');
            
            loadFiles();
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Manual file addition functions
        function addManualFile() {
            const input = document.getElementById('manualFileName');
            const fileName = input.value.trim();
            
            if (!fileName) {
                showStatus('Please enter a filename', 'error');
                return;
            }
            
            // Add .html extension if not present
            const finalFileName = fileName.endsWith('.html') || fileName.endsWith('.htm') ? 
                                 fileName : fileName + '.html';
            
            // Check if file already exists in our list
            if (allFiles.some(f => f.name === finalFileName)) {
                showStatus('File already in list', 'error');
                return;
            }
            
            // Add the file to our list
            allFiles.push({
                name: finalFileName,
                path: finalFileName,
                originalPath: finalFileName,
                displayName: finalFileName.replace(/\.(html|htm)$/i, ''),
                discovered: false,
                manual: true,
                lastModified: new Date(),
                size: 0,
                sizeFormatted: 'Unknown',
                method: 'manual'
            });
            
            input.value = '';
            showStatus(`Added ${finalFileName} manually`, 'success');
            
            // Refresh the display
            displayedItems = 0;
            loadFiles();
            saveLastSession(); // Save session after manual file addition
        }

        function showManualMode() {
            const currentList = allFiles.map(f => f.name).join(', ');
            const prompt = `Current files: ${currentList || 'None'}\n\nEnter additional HTML filenames (comma-separated):`;
            const input = window.prompt(prompt);
            
            if (input) {
                const fileNames = input.split(',').map(name => name.trim()).filter(name => name);
                let addedCount = 0;
                
                fileNames.forEach(fileName => {
                    const finalFileName = fileName.endsWith('.html') || fileName.endsWith('.htm') ? 
                                         fileName : fileName + '.html';
                    
                    if (!allFiles.some(f => f.name === finalFileName)) {
                        allFiles.push({
                            name: finalFileName,
                            path: finalFileName,
                            originalPath: finalFileName,
                            displayName: finalFileName.replace(/\.(html|htm)$/i, ''),
                            discovered: false,
                            manual: true,
                            lastModified: new Date(),
                            size: 0,
                            sizeFormatted: 'Unknown',
                            method: 'manual'
                        });
                        addedCount++;
                    }
                });
                
                if (addedCount > 0) {
                    showStatus(`Added ${addedCount} files manually`, 'success');
                    displayedItems = 0;
                    loadFiles();
                    saveLastSession(); // Save session after bulk manual addition
                } else {
                    showStatus('No new files added', 'error');
                }
            }
        }

        // Folder browsing functionality
        let currentFolderFiles = [];
        let isShowingFolderFiles = false;
        
        // Modern File System Access API handler with persistence
        async function handleModernDirectorySelection() {
            try {
                // Enhanced picker options with last folder attempt
                let pickerOptions = { 
                    mode: 'read',
                    // Some browsers support startIn to remember last location
                    startIn: 'documents' // Default to documents folder
                };
                
                // Try to use last folder as starting directory (if supported by browser)
                try {
                    const lastFolderData = localStorage.getItem(LAST_FOLDER_KEY);
                    if (lastFolderData) {
                        const parsed = JSON.parse(lastFolderData);
                        console.log('üîÑ Last folder accessed:', parsed.name, 'at', parsed.timestamp);
                        
                        // Show user which folder was last accessed
                        showStatus(`üí° Last folder: ${parsed.name}`, 'success');
                        
                        // Try to get saved directory handle if it exists
                        if (window.lastDirectoryHandle) {
                            console.log('üéØ Using saved directory handle');
                            pickerOptions.startIn = window.lastDirectoryHandle;
                        }
                    }
                } catch (e) {
                    console.log('Could not restore last folder info:', e);
                }
                
                // Show directory picker with enhanced options
                const directoryHandle = await window.showDirectoryPicker(pickerOptions);
                
                console.log('‚ú® Selected directory with File System Access API:', directoryHandle.name);
                
                // Get all HTML files from the directory
                const htmlFiles = [];
                await collectHTMLFiles(directoryHandle, htmlFiles, directoryHandle.name);
                
                if (htmlFiles.length === 0) {
                    showStatus('No HTML files found in selected directory', 'error');
                    return;
                }
                
                // Store all files for scanning
                window.selectedFolderFiles = htmlFiles.map(fileInfo => {
                    // Create a file object that looks like a traditional File object
                    const fileWithPath = fileInfo.file;
                    fileWithPath.webkitRelativePath = fileInfo.relativePath;
                    fileWithPath.directoryHandle = directoryHandle;
                    fileWithPath.fileHandle = fileInfo.handle;
                    fileWithPath.isModernAPI = true;
                    return fileWithPath;
                });
                
                // Show scan controls
                document.getElementById('scanControls').classList.remove('hidden');
                
                // Save this folder to our permanent library
                const folderInfo = {
                    name: directoryHandle.name,
                    handle: directoryHandle, // Save handle for future persistence
                    path: directoryHandle.name,
                    method: 'file-system-access',
                    addedAt: new Date().toISOString(),
                    fileCount: htmlFiles.length
                };
                
                // Add to saved folders library
                savedFolders.set(directoryHandle.name, folderInfo);
                
                // Save directory handle globally for next time (in memory only)
                window.lastDirectoryHandle = directoryHandle;
                
                // Update last folder tracking with enhanced data (no handle - can't serialize)
                localStorage.setItem(LAST_FOLDER_KEY, JSON.stringify({
                    name: directoryHandle.name,
                    path: directoryHandle.name,
                    timestamp: new Date().toISOString(),
                    method: 'file-system-access',
                    fullPath: `üìÅ ${directoryHandle.name}` // Human readable reference
                }));
                
                console.log('üíæ Saved last folder info:', directoryHandle.name);
                
                // Perform initial scan with default settings
                performFolderScan();
                
                showStatus(`‚úÖ Added folder "${directoryHandle.name}" to library with ${htmlFiles.length} HTML files`, 'success');
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('User cancelled directory selection');
                } else {
                    console.error('File System Access API error:', error);
                    throw error; // Re-throw to trigger fallback
                }
            }
        }
        
        // Recursively collect HTML files from directory
        async function collectHTMLFiles(directoryHandle, results, basePath = '') {
            try {
                for await (const entry of directoryHandle.values()) {
                    const relativePath = basePath ? `${basePath}/${entry.name}` : entry.name;
                    
                    if (entry.kind === 'file') {
                        if (entry.name.toLowerCase().endsWith('.html') || entry.name.toLowerCase().endsWith('.htm')) {
                            const file = await entry.getFile();
                            results.push({
                                file: file,
                                handle: entry,
                                relativePath: relativePath,
                                folderPath: basePath || directoryHandle.name
                            });
                        }
                    } else if (entry.kind === 'directory') {
                        // Recursively search subdirectories
                        await collectHTMLFiles(entry, results, relativePath);
                    }
                }
            } catch (error) {
                console.warn('Error reading directory:', error);
            }
        }

        function setupFolderBrowsing() {
            const selectFolderBtn = document.getElementById('selectFolderBtn');
            const currentFolderBtn = document.getElementById('currentFolderBtn');
            const folderInput = document.getElementById('folderInput');
            const rescanBtn = document.getElementById('rescanBtn');
            
            // Check if modern File System Access API is available
            const hasFileSystemAccess = 'showDirectoryPicker' in window;
            
            console.log('üîß Setting up folder browsing...');
            console.log('File System Access API available:', hasFileSystemAccess);

                        if (selectFolderBtn) {
                selectFolderBtn.addEventListener('click', async () => {
                    
                    // Show last folder info before opening picker
                    try {
                        const lastFolderData = localStorage.getItem(LAST_FOLDER_KEY);
                        if (lastFolderData) {
                            const parsed = JSON.parse(lastFolderData);
                            const timeSince = Math.round((Date.now() - new Date(parsed.timestamp).getTime()) / (1000 * 60 * 60)); // hours
                            const timeText = timeSince < 1 ? 'just now' : 
                                           timeSince < 24 ? `${timeSince} hours ago` : 
                                           `${Math.round(timeSince / 24)} days ago`;
                            showStatus(`üí° Opening folder browser... Last: ${parsed.name} (${timeText})`, 'success');
                        } else {
                            showStatus('üìÅ Opening folder browser...', 'success');
                        }
                    } catch (e) {
                        showStatus('üìÅ Opening folder browser...', 'success');
                    }
                    
                    if (hasFileSystemAccess) {
                        try {
                            // Use modern File System Access API
                            await handleModernDirectorySelection();
                        } catch (error) {
                            console.warn('File System Access API failed, falling back to input:', error);
                            // Fallback to traditional method
                            folderInput.click();
                        }
                    } else {
                        // Use traditional input method
                        folderInput.click();
                    }
                });
            }

            if (currentFolderBtn) {
                currentFolderBtn.addEventListener('click', () => {
                    isShowingFolderFiles = false;
                    window.selectedFolderFiles = null;
                    // Hide scan controls
                    document.getElementById('scanControls').classList.add('hidden');
                    refreshFiles();
                    updateFolderButtons();
                });
            }

            if (rescanBtn) {
                rescanBtn.addEventListener('click', () => {
                    performFolderScan();
                });
            }

            // Add event listeners for scan controls
            const scanDepth = document.getElementById('scanDepth');
            const includeSubdirs = document.getElementById('includeSubdirs');
            
            if (scanDepth) {
                scanDepth.addEventListener('change', () => {
                    if (window.selectedFolderFiles) {
                        performFolderScan();
                    }
                });
            }
            
            if (includeSubdirs) {
                includeSubdirs.addEventListener('change', () => {
                    if (window.selectedFolderFiles) {
                        performFolderScan();
                    }
                });
            }

            const resetBtn = document.getElementById('resetBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    resetAllPreviews();
                });
            }

            const clearDataBtn = document.getElementById('clearDataBtn');
            if (clearDataBtn) {
                clearDataBtn.addEventListener('click', () => {
                    if (confirm('This will clear ALL saved data including favorites, sessions, and preferences. Are you sure?')) {
                        clearStoredData();
                        resetAllPreviews();
                    }
                });
            }

            const bookmarkSettingsBtn = document.getElementById('bookmarkSettingsBtn');
            if (bookmarkSettingsBtn) {
                bookmarkSettingsBtn.addEventListener('click', () => {
                    changeBookmarkFolder();
                });
            }

            if (folderInput) {
                folderInput.addEventListener('change', handleFolderSelection);
            }
        }

        function handleFolderSelection(event) {
            const files = Array.from(event.target.files);
            const allHtmlFiles = files.filter(file => 
                file.name.toLowerCase().endsWith('.html') || 
                file.name.toLowerCase().endsWith('.htm')
            );

            if (allHtmlFiles.length === 0) {
                showStatus('No HTML files found in selected folder', 'error');
                return;
            }

            // Store all files for scanning
            window.selectedFolderFiles = allHtmlFiles;
            
            // Get folder path for constructing real URLs
            const baseFolderPath = allHtmlFiles[0].webkitRelativePath ? 
                                  allHtmlFiles[0].webkitRelativePath.split('/')[0] : 
                                  'Selected Folder';
            
            // Show scan controls
            document.getElementById('scanControls').classList.remove('hidden');
            
            // Save this folder to our permanent library
            const folderInfo = {
                name: baseFolderPath,
                path: baseFolderPath,
                method: 'traditional-input',
                addedAt: new Date().toISOString(),
                fileCount: allHtmlFiles.length,
                files: allHtmlFiles.map(f => f.name) // Store file list for "Add Files" feature
            };
            
            // Add to saved folders library
            savedFolders.set(baseFolderPath, folderInfo);
            
            // Update last folder tracking
            localStorage.setItem(LAST_FOLDER_KEY, JSON.stringify({
                name: baseFolderPath,
                path: baseFolderPath,
                timestamp: new Date().toISOString(),
                method: 'traditional-input'
            }));
            
            // Save all data to persist folder library
            saveAllData();
            
            // Perform initial scan with default settings
            performFolderScan();
            
            showStatus(`‚úÖ Added folder "${baseFolderPath}" to library with ${allHtmlFiles.length} HTML files`, 'success');
        }

        function performFolderScan() {
            if (!window.selectedFolderFiles) {
                showStatus('No folder selected', 'error');
                return;
            }
            
            const scanDepth = document.getElementById('scanDepth').value;
            const includeSubdirs = document.getElementById('includeSubdirs').checked;
            
            let filesToProcess = window.selectedFolderFiles;
            
            // Filter by subdirectory preference
            if (!includeSubdirs) {
                // Only include files in the root directory (no / in relative path except for filename)
                filesToProcess = filesToProcess.filter(file => {
                    const pathParts = file.webkitRelativePath.split('/');
                    return pathParts.length <= 2; // folder/file.html
                });
            }
            
            // Sort by last modified (newest first)
            filesToProcess.sort((a, b) => b.lastModified - a.lastModified);
            
            // Apply scan depth limit
            if (scanDepth !== 'all') {
                const limit = parseInt(scanDepth);
                filesToProcess = filesToProcess.slice(0, limit);
            }
            
            // Convert to our file format with REAL file:// URLs
            allFiles = filesToProcess.map(file => {
                // Extract folder structure from webkitRelativePath
                let folderPath = 'Selected Folder';
                let realFileUrl = null;
                
                if (file.webkitRelativePath) {
                    const pathParts = file.webkitRelativePath.split('/');
                    if (pathParts.length > 1) {
                        pathParts.pop(); // Remove filename
                        folderPath = pathParts.join('/');
                    }
                    
                    // CONSTRUCT REAL FILE:// URLs from webkitRelativePath!
                    // The webkitRelativePath gives us the EXACT folder structure selected
                    console.log(`üîç ANALYZING FILE: ${file.name}`);
                    console.log(`üîç webkitRelativePath: ${file.webkitRelativePath}`);
                    
                    if (window.location.protocol === 'file:') {
                        const currentPath = decodeURIComponent(window.location.pathname);
                        const currentDirPath = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
                        
                        // Extract the actual folder structure from webkitRelativePath
                        const relativePath = file.webkitRelativePath;
                        const pathParts = relativePath.split('/');
                        const fileName = pathParts.pop(); // Remove filename, keep folder structure
                        const selectedFolderStructure = pathParts.join('/');
                        
                        console.log(`üîç Current dir path: ${currentDirPath}`);
                        console.log(`üîç Selected folder structure: ${selectedFolderStructure}`);
                        console.log(`üîç File name: ${fileName}`);
                        
                        // Build the real path by going up from current directory and using the selected folder structure
                        // The user selected a folder, so we need to construct the path to that folder
                        const parentDirPath = currentDirPath.substring(0, currentDirPath.lastIndexOf('/', currentDirPath.length - 2) + 1);
                        
                        // Method 1: Try using the selected folder structure directly from parent
                        realFileUrl = 'file://' + (parentDirPath + relativePath).replace(/\\/g, '/');
                        
                        console.log(`üéØ CONSTRUCTED REAL PATH (Method 1): ${realFileUrl}`);
                        console.log(`   Parent dir: ${parentDirPath}`);
                        console.log(`   Full relative path: ${relativePath}`);
                        
                        // Save this absolute path for permanent access
                        saveAbsoluteFilePath(fileName, realFileUrl, {
                            source: 'folder-selection',
                            webkitRelativePath: file.webkitRelativePath,
                            folderName: selectedFolderStructure,
                            constructionMethod: 'parent-plus-relative'
                        });
                    } else {
                        // HTTP protocol
                        const currentUrl = window.location.href;
                        const currentDir = currentUrl.substring(0, currentUrl.lastIndexOf('/') + 1);
                        realFileUrl = currentDir + file.webkitRelativePath;
                        console.log(`üåê HTTP REAL PATH: ${realFileUrl}`);
                        
                        // Save this absolute path for permanent access
                        saveAbsoluteFilePath(fileName, realFileUrl, {
                            source: 'folder-selection-http',
                            webkitRelativePath: file.webkitRelativePath,
                            folderName: pathParts.length > 1 ? pathParts[0] : ''
                        });
                    }
                }
                
                // Determine the method and path handling
                let method = 'folder-browse';
                let path = URL.createObjectURL(file);
                let originalPath = file.name;
                let realPathAvailable = false;
                
                if (file.isModernAPI && file.directoryHandle) {
                    // File System Access API - also try to construct real paths
                    method = 'file-system-access';
                    if (realFileUrl) {
                        path = realFileUrl;
                        originalPath = realFileUrl;
                        realPathAvailable = true;
                        console.log(`üÜï File System Access API with REAL PATH: ${realFileUrl}`);
                    } else {
                        console.log(`üÜï File System Access API with blob URL: ${file.name}`);
                    }
                } else if (realFileUrl) {
                    // Traditional folder input with constructed real URL
                    method = 'folder-real-path';
                    path = realFileUrl;
                    originalPath = realFileUrl;
                    realPathAvailable = true;
                    console.log(`üìÅ Traditional folder selection with REAL PATH: ${realFileUrl}`);
                } else {
                    // Traditional folder input with blob URL (fallback)
                    method = 'folder-browse';
                    console.log(`üìÅ Traditional folder input fallback to blob URL: ${file.name}`);
                }
                
                return {
                    name: file.name,
                    path: path,
                    originalPath: originalPath,
                    displayName: file.name.replace(/\.(html|htm)$/i, ''),
                    discovered: true,
                    lastModified: new Date(file.lastModified),
                    size: file.size,
                    sizeFormatted: formatFileSize(file.size),
                    method: method,
                    file: file,
                    folderPath: folderPath,
                    fullPath: file.webkitRelativePath,
                    realPathAvailable: realPathAvailable,
                    directoryHandle: file.directoryHandle,
                    fileHandle: file.fileHandle
                };
            });

            isShowingFolderFiles = true;
            displayedItems = 0;
            
            // Clear current display and show folder files
            document.getElementById('filesGrid').innerHTML = '';
            document.getElementById('loadingIndicator').classList.add('hidden');
            document.getElementById('noResults').classList.add('hidden');
            document.getElementById('errorMessage').classList.add('hidden');
            
            loadFiles();
            updateFolderButtons();
            saveLastSession();
            
            const folderName = window.selectedFolderFiles[0].webkitRelativePath ? 
                              window.selectedFolderFiles[0].webkitRelativePath.split('/')[0] : 
                              'Selected Folder';
            
            const modernAPICount = allFiles.filter(f => f.method === 'file-system-access').length;
            const totalFiles = window.selectedFolderFiles.length;
            const apiType = modernAPICount > 0 ? 'File System Access API' : 'Traditional folder input';
            
            // Save folder information for future use  
            const folderPath = folderName;
            
                        // Save folder information for future use
            saveFolderInfo(folderPath, folderName);
            
            // Update directory info
            document.getElementById('currentPath').textContent = 
                `üìÅ ${folderName} ‚Ä¢ ${allFiles.length}/${totalFiles} files ‚Ä¢ ${apiType} ‚Ä¢ Blob URLs (secure) ‚Ä¢ ${includeSubdirs ? 'with' : 'without'} subdirectories`;
            
            showStatus(`Scanned ${allFiles.length} files using ${apiType} (blob URLs for security)`, 'success');
        }

        function handleFileSelection(event) {
            const files = Array.from(event.target.files);
            const htmlFiles = files.filter(file => 
                file.name.toLowerCase().endsWith('.html') || 
                file.name.toLowerCase().endsWith('.htm')
            );

            if (htmlFiles.length === 0) {
                showStatus('No HTML files selected', 'error');
                return;
            }

            // Add selected files to existing files (don't replace)
            const newFiles = htmlFiles.map(file => {
                // Extract folder path from webkitRelativePath if available
                let folderPath = null; // Don't set folder path for individual files
                let fullPath = file.name;
                
                if (file.webkitRelativePath) {
                    const pathParts = file.webkitRelativePath.split('/');
                    if (pathParts.length > 1) {
                        pathParts.pop(); // Remove filename
                        folderPath = pathParts.join('/');
                        fullPath = file.webkitRelativePath;
                    }
                }
                
                return {
                    name: file.name,
                    path: URL.createObjectURL(file),
                    originalPath: file.name,
                    displayName: file.name.replace(/\.(html|htm)$/i, ''),
                    discovered: true,
                    lastModified: new Date(file.lastModified),
                    size: file.size,
                    sizeFormatted: formatFileSize(file.size),
                    method: 'file-add',
                    file: file,
                    folderPath: folderPath,
                    fullPath: fullPath
                };
            });

            // Filter out duplicates (same name)
            const existingNames = allFiles.map(f => f.name);
            const uniqueNewFiles = newFiles.filter(f => !existingNames.includes(f.name));

            if (uniqueNewFiles.length === 0) {
                showStatus('All selected files are already in the list', 'warning');
                return;
            }

            // Add unique files to the current list
            allFiles.push(...uniqueNewFiles);
            
            // Update display
            displayedItems = allFiles.length - uniqueNewFiles.length; // Start from where we left off
            loadFiles();
            saveLastSession(); // Save session after adding files
            
            const addedCount = uniqueNewFiles.length;
            const skippedCount = htmlFiles.length - addedCount;
            
            let statusMessage = `Added ${addedCount} HTML file${addedCount === 1 ? '' : 's'}`;
            if (skippedCount > 0) {
                statusMessage += ` (${skippedCount} duplicate${skippedCount === 1 ? '' : 's'} skipped)`;
            }
            
            // Check if any files don't have folder paths
            const filesWithoutPath = uniqueNewFiles.filter(f => !f.folderPath);
            if (filesWithoutPath.length > 0) {
                statusMessage += ' ‚Ä¢ Use "Add Folders" to save folder locations';
            }
            
            showStatus(statusMessage, 'success');
            
            // Update directory info if showing current mode
            if (!isShowingFolderFiles) {
                document.getElementById('currentPath').textContent = `Current directory + ${allFiles.filter(f => f.method === 'file-add').length} added files`;
            }
            
            // Update results counter
            updateResultsCounter();
            
            // Clear the file input for next selection
            event.target.value = '';
        }

        function updateFolderButtons() {
            const selectFolderBtn = document.getElementById('selectFolderBtn');
            const addFilesBtn = document.getElementById('addFilesBtn');
            const currentFolderBtn = document.getElementById('currentFolderBtn');
            
            if (selectFolderBtn && addFilesBtn && currentFolderBtn) {
                const addedFilesCount = allFiles.filter(f => f.method === 'file-add').length;
                
                if (isShowingFolderFiles) {
                    // Folder mode - update folder button
                    selectFolderBtn.classList.remove('from-blue-500', 'to-purple-600');
                    selectFolderBtn.classList.add('from-green-500', 'to-green-600');
                    selectFolderBtn.innerHTML = '<i class="fas fa-check text-sm sm:text-lg"></i><span class="text-sm sm:text-base">Folder Added</span>';
                    
                    // Keep add files button active - users can always add more files
                    addFilesBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    addFilesBtn.disabled = false;
                    
                    currentFolderBtn.classList.remove('bg-gray-600');
                    currentFolderBtn.classList.add('bg-blue-600');
                } else {
                    // Current directory mode
                    selectFolderBtn.classList.remove('from-green-500', 'to-green-600');
                    selectFolderBtn.classList.add('from-blue-500', 'to-purple-600');
                    selectFolderBtn.innerHTML = '<i class="fas fa-folder-open text-sm sm:text-lg"></i><span class="text-sm sm:text-base">Add Folders</span>';
                    
                    // Enable add files button and show count if files added
                    addFilesBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    addFilesBtn.disabled = false;
                    
                    if (addedFilesCount > 0) {
                        addFilesBtn.classList.remove('from-green-500', 'to-emerald-600');
                        addFilesBtn.classList.add('from-green-600', 'to-emerald-700');
                        addFilesBtn.innerHTML = `<i class="fas fa-file-plus text-sm sm:text-lg"></i><span class="text-sm sm:text-base">Added (${addedFilesCount})</span>`;
                    } else {
                        addFilesBtn.classList.remove('from-green-600', 'to-emerald-700');
                        addFilesBtn.classList.add('from-green-500', 'to-emerald-600');
                        addFilesBtn.innerHTML = '<i class="fas fa-file-plus text-sm sm:text-lg"></i><span class="text-sm sm:text-base">Add Files</span>';
                    }
                    
                    currentFolderBtn.classList.remove('bg-blue-600');
                    currentFolderBtn.classList.add('bg-gray-600');
                }
            }
        }

                    // Session restore functions
            function restoreSession() {
                const sessionRestored = loadLastSession();
                if (sessionRestored && allFiles.length > 0) {
                    displayedItems = 0;
                    loadFiles();
                    document.getElementById('sessionInfo').classList.add('hidden');
                    showStatus('Session restored successfully', 'success');
                } else {
                    showStatus('Failed to restore session', 'error');
                }
            }

            function clearSession() {
                localStorage.removeItem(LAST_SESSION_KEY);
                document.getElementById('sessionInfo').classList.add('hidden');
                showStatus('Session cleared, starting fresh', 'success');
                scanDirectory();
            }

            function checkForPreviousSession() {
                try {
                    const saved = localStorage.getItem(LAST_SESSION_KEY);
                    if (saved) {
                        const sessionData = JSON.parse(saved);
                        const sessionAge = Date.now() - new Date(sessionData.timestamp).getTime();
                        const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
                        
                        if (sessionAge <= maxAge && sessionData.fileCount > 0) {
                            const sessionInfo = document.getElementById('sessionInfo');
                            const sessionDetails = document.getElementById('sessionDetails');
                            
                            const ageText = sessionAge < 60000 ? 'just now' : 
                                          sessionAge < 3600000 ? `${Math.round(sessionAge / 60000)} minutes ago` :
                                          sessionAge < 86400000 ? `${Math.round(sessionAge / 3600000)} hours ago` :
                                          `${Math.round(sessionAge / 86400000)} days ago`;
                            
                            sessionDetails.textContent = `${sessionData.fileCount} files loaded ${ageText}`;
                            sessionInfo.classList.remove('hidden');
                            return true;
                        }
                    }
                } catch (e) {
                    console.warn('Error checking previous session:', e);
                }
                return false;
            }

            // ========== NEW ENHANCED FEATURES ==========
            
            // Folder Location Opening
            function openFileLocation(file) {
                try {
                    // Get the file path for opening location
                    let pathToShow = '';
                    let actualFolderPath = '';
                    
                    console.log('üîç Opening file location for:', file);
                    console.log('File method:', file.method);
                    console.log('File folderPath:', file.folderPath);
                    console.log('File fullPath:', file.fullPath);
                    console.log('File originalPath:', file.originalPath);
                    
                    if (file.method === 'folder-real-path' || file.method === 'tracker-discovered' || file.realPathAvailable) {
                        // For files with real paths, extract directory
                        const realPath = file.originalPath || file.path;
                        if (realPath.startsWith('file://')) {
                            pathToShow = decodeURIComponent(realPath.replace('file:///', '').replace(/\//g, '\\'));
                            pathToShow = pathToShow.substring(0, pathToShow.lastIndexOf('\\'));
                        }
                    } else if (file.method === 'folder-browse' || file.method === 'file-system-access') {
                        // For folder-selected files, try to construct the actual path
                        const currentUrl = window.location.href;
                        if (currentUrl.startsWith('file://')) {
                            const currentPath = decodeURIComponent(currentUrl.replace('file:///', '').replace(/\//g, '\\'));
                            const currentDir = currentPath.substring(0, currentPath.lastIndexOf('\\'));
                            
                            if (file.fullPath && file.fullPath !== file.name) {
                                // Use the webkitRelativePath to construct the actual path
                                const relativePath = file.fullPath.replace(/\//g, '\\');
                                const fileName = relativePath.split('\\').pop();
                                const folderStructure = relativePath.substring(0, relativePath.lastIndexOf('\\'));
                                
                                // Try different path construction strategies
                                const pathParts = folderStructure.split('\\');
                                const selectedFolderName = pathParts[0];
                                const currentDirName = currentDir.split('\\').pop();
                                
                                if (selectedFolderName === currentDirName) {
                                    // Same directory
                                    pathToShow = currentDir;
                                    actualFolderPath = currentDir;
                                } else {
                                    // Different directory - try sibling or parent paths
                                    const parentDir = currentDir.substring(0, currentDir.lastIndexOf('\\'));
                                    pathToShow = parentDir + '\\' + selectedFolderName;
                                    actualFolderPath = pathToShow;
                                    
                                    // If there are subdirectories, add them
                                    if (pathParts.length > 1) {
                                        const subPath = pathParts.slice(1).join('\\');
                                        pathToShow = pathToShow + '\\' + subPath;
                                        actualFolderPath = pathToShow;
                                    }
                                }
                                
                                console.log('üéØ Constructed path from webkitRelativePath:', pathToShow);
                            } else {
                                // Fallback to current directory
                                pathToShow = currentDir;
                                actualFolderPath = currentDir;
                            }
                        }
                    } else if (file.folderPath && file.folderPath !== 'Unknown location' && file.folderPath !== 'Selected Folder') {
                        pathToShow = file.folderPath;
                        actualFolderPath = pathToShow;
                    } else {
                        // For current directory files
                        const currentUrl = window.location.href;
                        if (currentUrl.startsWith('file://')) {
                            pathToShow = decodeURIComponent(currentUrl.replace('file:///', '').replace(/\//g, '\\'));
                            pathToShow = pathToShow.substring(0, pathToShow.lastIndexOf('\\'));
                            actualFolderPath = pathToShow;
                        }
                    }
                    
                    if (pathToShow) {
                        // Enhanced instructions with more details
                        const isEstimated = pathToShow.includes('[Browser Selected]') || 
                                          (file.method === 'folder-browse' && !actualFolderPath.startsWith('C:') && !actualFolderPath.startsWith('D:'));
                        
                        const instructions = 
                            `üìÅ File Location Information\n\n` +
                            `File: ${file.name}\n` +
                            `${isEstimated ? 'Estimated ' : ''}Location: ${pathToShow}\n` +
                            `${file.fullPath ? `Relative Path: ${file.fullPath}\n` : ''}` +
                            `${isEstimated ? 'Method: Browser folder selection (exact path estimated)\n' : ''}\n` +
                            `To open this location:\n` +
                            `‚Ä¢ Windows: Win+R, type: explorer "${pathToShow}"\n` +
                            `‚Ä¢ Or copy path and paste in File Explorer address bar\n` +
                            `‚Ä¢ If path doesn't exist, try the parent directory\n\n` +
                            `${isEstimated ? '‚ö†Ô∏è Note: Browser security limits exact path detection for user-selected folders.\nThe path shown is our best estimate based on your current location.\n\n' : ''}` +
                            `Path copied to clipboard if possible.`;
                        
                        // Try to copy the most likely path to clipboard
                        const pathToCopy = actualFolderPath || pathToShow;
                        if (navigator.clipboard && pathToCopy) {
                            navigator.clipboard.writeText(pathToCopy).catch(() => {});
                        }
                        
                        alert(instructions);
                        showStatus(`üìÅ ${isEstimated ? 'Estimated' : 'Copied'} folder path: ${pathToShow}`, 'success');
                    } else {
                        showStatus('üìÅ Folder path not available for this file', 'error');
                    }
                    
                } catch (error) {
                    console.error('Error opening file location:', error);
                    showStatus('‚ùå Error determining file location', 'error');
                }
            }
            
            // Tagging System
            function showTagDialog(fileName) {
                try {
                    const currentTags = fileTags.get(fileName) || new Set();
                    const currentTagsArray = Array.from(currentTags);
                    
                    const tagsInput = prompt(
                        `üè∑Ô∏è Tags for "${fileName}"\n\n` +
                        `Current tags: ${currentTagsArray.length > 0 ? currentTagsArray.join(', ') : 'None'}\n\n` +
                        `Enter tags (comma-separated):\n` +
                        `Examples: "template, responsive, bootstrap" or "landing-page, dark-theme"`,
                        currentTagsArray.join(', ')
                    );
                    
                    if (tagsInput !== null) {
                        // Parse and clean tags
                        const newTags = tagsInput
                            .split(',')
                            .map(tag => tag.trim().toLowerCase())
                            .filter(tag => tag.length > 0 && tag.length <= 30); // Limit tag length
                        
                        if (newTags.length > 0) {
                            fileTags.set(fileName, new Set(newTags));
                            showStatus(`üè∑Ô∏è Added ${newTags.length} tags to ${fileName}`, 'success');
                        } else {
                            fileTags.delete(fileName);
                            showStatus(`üè∑Ô∏è Cleared tags for ${fileName}`, 'success');
                        }
                        
                        saveAllData();
                        updateAllCounters();
                        
                        // Refresh display if currently filtering by tags
                        if (currentFilter === 'tagged') {
                            displayedItems = 0;
                            loadFiles();
                        }
                        
                        // Update tag filter dropdown
                        updateTagFilterDropdown();
                    }
                } catch (error) {
                    console.error('Error in tag dialog:', error);
                    showStatus('‚ùå Error managing tags', 'error');
                }
            }
            
            // Selection Mode Management
            function toggleSelectionMode() {
                isSelectionMode = !isSelectionMode;
                const cards = document.querySelectorAll('.style-card');
                const selectionBtn = document.getElementById('selectionModeBtn');
                const bulkPanel = document.getElementById('bulkActionPanel');
                const openAllBtn = document.getElementById('openAllBtn');
                
                if (isSelectionMode) {
                    // Enter selection mode
                    cards.forEach(card => {
                        card.classList.add('selection-mode');
                    });
                    selectionBtn.innerHTML = '<i class="fas fa-times text-sm sm:text-lg"></i><span class="text-sm sm:text-base">Cancel</span>';
                    selectionBtn.classList.remove('bg-indigo-500', 'hover:bg-indigo-600');
                    selectionBtn.classList.add('bg-gray-500', 'hover:bg-gray-600');
                    bulkPanel.classList.remove('hidden');
                    openAllBtn.classList.remove('hidden');
                } else {
                    // Exit selection mode
                    cards.forEach(card => {
                        card.classList.remove('selection-mode', 'selected');
                        const checkbox = card.querySelector('.file-checkbox');
                        if (checkbox) checkbox.checked = false;
                    });
                    selectionBtn.innerHTML = '<i class="fas fa-check-square text-sm sm:text-lg"></i><span class="text-sm sm:text-base">Select</span>';
                    selectionBtn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                    selectionBtn.classList.add('bg-indigo-500', 'hover:bg-indigo-600');
                    bulkPanel.classList.add('hidden');
                    openAllBtn.classList.add('hidden');
                    selectedFiles.clear();
                    updateSelectedCount();
                }
            }
            
            function handleFileSelection(fileName, isSelected) {
                const card = document.querySelector(`[data-file-name="${fileName}"]`);
                
                if (isSelected) {
                    selectedFiles.add(fileName);
                    if (card) card.classList.add('selected');
                } else {
                    selectedFiles.delete(fileName);
                    if (card) card.classList.remove('selected');
                }
                
                updateSelectedCount();
            }
            
            function updateSelectedCount() {
                const countElement = document.getElementById('selectedCount');
                const count = selectedFiles.size;
                countElement.textContent = `${count} file${count === 1 ? '' : 's'} selected`;
            }
            
            function selectAllFiles() {
                const checkboxes = document.querySelectorAll('.file-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                    const fileName = checkbox.dataset.filename;
                    selectedFiles.add(fileName);
                    const card = checkbox.closest('.style-card');
                    if (card) card.classList.add('selected');
                });
                updateSelectedCount();
            }
            
            function clearSelection() {
                const checkboxes = document.querySelectorAll('.file-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                    const card = checkbox.closest('.style-card');
                    if (card) card.classList.remove('selected');
                });
                selectedFiles.clear();
                updateSelectedCount();
            }
            
            // Bulk Actions
            function performBulkAction(action) {
                if (selectedFiles.size === 0) {
                    showStatus('No files selected', 'error');
                    return;
                }
                
                const fileNames = Array.from(selectedFiles);
                
                try {
                    switch (action) {
                        case 'favorite':
                            fileNames.forEach(fileName => {
                                if (favorites.has(fileName)) {
                                    favorites.delete(fileName);
                                } else {
                                    favorites.add(fileName);
                                }
                                updateFavoriteButton(fileName);
                            });
                            saveFavorites();
                            showStatus(`Updated favorites for ${fileNames.length} files`, 'success');
                            break;
                            
                        case 'bookmark':
                            let bookmarkedCount = 0;
                            fileNames.forEach(fileName => {
                                const file = allFiles.find(f => f.name === fileName);
                                if (file && !bookmarkedFiles.has(fileName)) {
                                    bookmarkedFiles.add(fileName);
                                    bookmarkedCount++;
                                }
                            });
                            saveBookmarks();
                            showStatus(`Added ${bookmarkedCount} files to bookmarks`, 'success');
                            break;
                            
                        case 'tag':
                            const tagInput = prompt(
                                `üè∑Ô∏è Add tags to ${fileNames.length} selected files\n\n` +
                                `Enter tags (comma-separated):`,
                                ''
                            );
                            
                            if (tagInput !== null && tagInput.trim()) {
                                const tags = tagInput.split(',').map(tag => tag.trim().toLowerCase()).filter(tag => tag.length > 0);
                                fileNames.forEach(fileName => {
                                    const existingTags = fileTags.get(fileName) || new Set();
                                    tags.forEach(tag => existingTags.add(tag));
                                    fileTags.set(fileName, existingTags);
                                });
                                saveAllData();
                                showStatus(`Added tags to ${fileNames.length} files`, 'success');
                                updateTagFilterDropdown();
                            }
                            break;
                            
                        case 'remove':
                            if (confirm(`Remove ${fileNames.length} files from view?\n\nFiles will not be deleted, just hidden from this session.`)) {
                                allFiles = allFiles.filter(file => !selectedFiles.has(file.name));
                                displayedItems = 0;
                                loadFiles();
                                selectedFiles.clear();
                                toggleSelectionMode(); // Exit selection mode
                                showStatus(`Removed ${fileNames.length} files from view`, 'success');
                            }
                            break;
                            
                        case 'delete':
                            if (confirm(`Delete ${fileNames.length} files?\n\nThis will open file locations so you can delete them manually.`)) {
                                fileNames.forEach(fileName => {
                                    const file = allFiles.find(f => f.name === fileName);
                                    if (file) openFileLocation(file);
                                });
                                showStatus(`Opened ${fileNames.length} file locations for deletion`, 'success');
                            }
                            break;
                    }
                    
                    updateAllCounters();
                    
                } catch (error) {
                    console.error('Error in bulk action:', error);
                    showStatus(`‚ùå Error performing bulk ${action}`, 'error');
                }
            }
            
            // Enhanced Open All Feature with Infinite Scroll & Controlled Opening
            function openAllSelected() {
                if (selectedFiles.size === 0) {
                    showStatus('No files selected', 'error');
                    return;
                }
                
                const fileNames = Array.from(selectedFiles);
                const batchSize = 5; // Open files in batches of 5
                const totalFiles = fileNames.length;
                
                // Enhanced confirmation with batch information
                const confirmMsg = totalFiles <= batchSize ? 
                    `Open ${totalFiles} selected files in new tabs?` :
                    `Open ${totalFiles} selected files?\n\nüîÑ Files will open in batches of ${batchSize} to prevent browser overload.\nüìä Total batches: ${Math.ceil(totalFiles / batchSize)}\n‚è±Ô∏è Estimated time: ${Math.ceil(totalFiles / batchSize) * 2} seconds`;
                
                if (!confirm(confirmMsg)) {
                    return;
                }
                
                // Start batch processing with infinite scroll approach
                openFilesBatchInfinite(fileNames, 0, batchSize);
            }
            
            // Infinite scroll batch opener
            function openFilesBatchInfinite(fileNames, startIndex, batchSize) {
                const currentBatch = fileNames.slice(startIndex, startIndex + batchSize);
                const totalFiles = fileNames.length;
                const currentBatchNum = Math.floor(startIndex / batchSize) + 1;
                const totalBatches = Math.ceil(totalFiles / batchSize);
                
                if (currentBatch.length === 0) {
                    showStatus(`‚úÖ All ${totalFiles} files opened successfully!`, 'success');
                    saveAllData();
                    return;
                }
                
                // Show progress
                showStatus(`üìÇ Opening batch ${currentBatchNum}/${totalBatches} (${currentBatch.length} files)...`, 'scanning');
                
                let openedCount = 0;
                
                // Open files in current batch
                currentBatch.forEach((fileName, index) => {
                    const file = allFiles.find(f => f.name === fileName);
                    if (file) {
                        try {
                            // Add delay between file opens to prevent browser freeze
                            setTimeout(() => {
                                openFile(file);
                                addToRecentFiles(file);
                                openedCount++;
                                
                                // Update progress
                                const totalOpened = startIndex + openedCount;
                                console.log(`üìä Opened ${totalOpened}/${totalFiles} files`);
                                
                            }, index * 200); // 200ms delay between each file
                            
                        } catch (error) {
                            console.warn(`Failed to open ${fileName}:`, error);
                        }
                    }
                });
                
                // Schedule next batch with user interaction (infinite scroll approach)
                const nextStartIndex = startIndex + batchSize;
                if (nextStartIndex < totalFiles) {
                    const remainingFiles = totalFiles - nextStartIndex;
                    const nextBatchNum = currentBatchNum + 1;
                    
                    setTimeout(() => {
                        // Show continuation prompt for infinite scroll behavior
                        const continueMsg = `üéØ Batch ${currentBatchNum} complete!\n\n` +
                            `üìä Progress: ${nextStartIndex}/${totalFiles} files opened\n` +
                            `üìÇ Next batch: ${Math.min(batchSize, remainingFiles)} files\n\n` +
                            `Continue with batch ${nextBatchNum}/${totalBatches}?`;
                        
                        if (confirm(continueMsg)) {
                            // Continue with next batch
                            openFilesBatchInfinite(fileNames, nextStartIndex, batchSize);
                        } else {
                            showStatus(`‚è∏Ô∏è Stopped after opening ${nextStartIndex} files`, 'success');
                            saveAllData();
                        }
                    }, Math.max(currentBatch.length * 200, 1000)); // Wait for current batch to finish
                } else {
                    // Final batch complete
                    setTimeout(() => {
                        showStatus(`üéâ All ${totalFiles} files opened successfully!`, 'success');
                        saveAllData();
                    }, currentBatch.length * 200);
                }
            }
            
                    // Enhanced Folder Library - Add Files from Saved Folders
        function showAddFilesDialog() {
            const hasAbsolutePaths = absoluteFilePaths.size > 0;
            const hasSavedFolders = savedFolders.size > 0;
            
            if (!hasAbsolutePaths && !hasSavedFolders) {
                // Enhanced empty state handling
                showStatus('üìÅ No folders added yet. Add a folder first!', 'warning');
                
                const shouldAddFolder = confirm(
                    'üìÇ No Folders Added Yet\n\n' +
                    'üö´ Your folder library is empty.\n' +
                    'üéØ Add a folder first to use this feature.\n\n' +
                    '‚Ä¢ Click OK: Add your first folder now\n' +
                    '‚Ä¢ Click Cancel: Continue browsing\n\n' +
                    'Once you add folders, you can easily select files from them here.'
                );
                
                if (shouldAddFolder) {
                    // Trigger the add folder functionality
                    document.getElementById('selectFolderBtn').click();
                } else {
                    // Show helpful message
                    showStatus('üí° Use "Add Folders" button to build your library first', 'info');
                }
                return;
            }
            
            // Enhanced folder display when folders exist
            showStatus('üìÇ Displaying folders from your library...', 'success');
            
            // Show enhanced folder library interface
            const folderList = Array.from(savedFolders.entries()).map(([folderPath, folderInfo], index) => {
                const addedDate = new Date(folderInfo.addedAt).toLocaleDateString();
                const fileCount = folderInfo.fileCount || 0;
                const method = folderInfo.method === 'file-system-access' ? 'üÜï' : 'üìÅ';
                return `${method} ${folderInfo.name} (${fileCount} files) - Added ${addedDate}`;
            }).join('\n');
            
            let options = 'üìÇ YOUR FOLDER LIBRARY üìÇ\n\n';
            
            if (hasSavedFolders) {
                options += `${folderList}\n\n`;
                options += '1. Select files from a specific folder\n';
            }
            
            if (hasAbsolutePaths) {
                options += `2. Restore all saved file paths (${absoluteFilePaths.size} files)\n`;
            }
            
            options += '\nEnter option number:';
            
            const choice = prompt(options);
            
            if (choice === '1' && hasSavedFolders) {
                showSavedFoldersDialog();
            } else if (choice === '2' && hasAbsolutePaths) {
                restoreFromAbsolutePaths();
            }
                
        }
        
        // Restore files from saved absolute paths (works from anywhere)
        function restoreFromAbsolutePaths() {
            if (absoluteFilePaths.size === 0) {
                showStatus('No saved absolute paths available', 'error');
                return;
            }
            
            const pathEntries = Array.from(absoluteFilePaths.entries());
            
            if (confirm(`Restore ${pathEntries.length} files from saved absolute paths?\n\nThis will work regardless of where demoX.html is located.`)) {
                let restoredCount = 0;
                const restoredFiles = [];
                
                pathEntries.forEach(([fileName, pathInfo]) => {
                    try {
                        // Create a file object with the saved absolute path
                        const file = {
                            name: fileName,
                            path: pathInfo.absolutePath,
                            originalPath: pathInfo.absolutePath,
                            displayName: fileName.replace(/\.(html|htm)$/i, ''),
                            method: 'saved-absolute-path',
                            realPathAvailable: true,
                            discovered: true,
                            lastModified: new Date(pathInfo.savedAt),
                            size: 0,
                            sizeFormatted: 'Unknown',
                            savedAt: pathInfo.savedAt,
                            originalLocation: pathInfo.originalLocation,
                            source: pathInfo.source
                        };
                        
                        // Check if not already in current files
                        if (!allFiles.some(f => f.name === fileName)) {
                            restoredFiles.push(file);
                            restoredCount++;
                        }
                        
                    } catch (error) {
                        console.warn(`Failed to restore ${fileName}:`, error);
                    }
                });
                
                if (restoredCount > 0) {
                    allFiles.push(...restoredFiles);
                    displayedItems = 0;
                    loadFiles();
                    saveLastSession();
                    
                    showStatus(`üöÄ Restored ${restoredCount} files with absolute paths!`, 'success');
                } else {
                    showStatus('All saved files are already loaded', 'error');
                }
            }
        }
        
        // Show saved folders dialog
        function showSavedFoldersDialog() {
            if (savedFolders.size === 0) {
                showStatus('No saved folders available', 'error');
                return;
            }
            
            // Show saved folders selection with system paths
            const folderOptions = Array.from(savedFolders.entries()).map(([folderPath, folderInfo], index) => {
                const systemPath = folderInfo.systemPath || folderPath;
                const fileCount = folderInfo.fileCount || 0;
                const method = folderInfo.method === 'file-system-access' ? ' (Modern API)' : ' (Traditional)';
                return `${index + 1}. ${folderInfo.name}${method}\n   üìÅ ${systemPath}\n   üìÑ ${fileCount} files`;
            }).join('\n\n');
            
            const folderChoice = prompt(
                `üìÅ Saved Folders (${savedFolders.size})\n\n` +
                folderOptions + '\n\n' +
                `Enter folder number to add files from:`
            );
            
            if (folderChoice && !isNaN(folderChoice)) {
                const folderIndex = parseInt(folderChoice) - 1;
                const folderPaths = Array.from(savedFolders.keys());
                
                if (folderIndex >= 0 && folderIndex < folderPaths.length) {
                    const selectedFolderPath = folderPaths[folderIndex];
                    showStatus(`Selected folder: ${selectedFolderPath}`, 'success');
                    
                    // Here you would implement file selection from that specific folder
                    // For now, just show a message
                    alert(
                        `üîÑ Feature Coming Soon\n\n` +
                        `Selected folder: ${selectedFolderPath}\n\n` +
                        `Individual file selection from saved folders is being implemented.\n` +
                        `For now, use "Add Folders" to add folders to your library.`
                    );
                }
            }
        }
            
                    // Absolute Path Management for Permanent Access
        function saveAbsoluteFilePath(fileName, absolutePath, additionalInfo = {}) {
            try {
                absoluteFilePaths.set(fileName, {
                    absolutePath: absolutePath,
                    savedAt: new Date().toISOString(),
                    originalLocation: window.location.href,
                    ...additionalInfo
                });
                
                console.log(`üíæ Saved absolute path for ${fileName}: ${absolutePath}`);
                saveAllData();
                
            } catch (error) {
                console.error('Error saving absolute path:', error);
            }
        }
        
        function getAbsoluteFilePath(fileName) {
            const pathInfo = absoluteFilePaths.get(fileName);
            if (pathInfo) {
                console.log(`üìÅ Retrieved absolute path for ${fileName}: ${pathInfo.absolutePath}`);
                return pathInfo.absolutePath;
            }
            return null;
        }
        
        // Recent Files Management
        function addToRecentFiles(file) {
            // Remove if already exists
            recentFiles = recentFiles.filter(f => f.name !== file.name);
            
            // Get or determine absolute path
            let absolutePath = getAbsoluteFilePath(file.name);
            if (!absolutePath && (file.originalPath || file.path)) {
                absolutePath = file.originalPath || file.path;
            }
            
            // Add to beginning
            recentFiles.unshift({
                name: file.name,
                path: file.path,
                absolutePath: absolutePath,
                displayName: file.displayName,
                lastAccessed: new Date().toISOString()
            });
            
            // Limit to 10 files
            recentFiles = recentFiles.slice(0, 10);
            
            saveAllData();
        }
            
            // Counter Updates
            function updateAllCounters() {
                updateFavoritesCount();
                updateBookmarksCount();
                updateTaggedCount();
            }
            
            function updateTaggedCount() {
                const countElement = document.getElementById('taggedCount');
                const count = fileTags.size;
                
                if (count > 0) {
                    countElement.textContent = count;
                    countElement.classList.remove('hidden');
                } else {
                    countElement.classList.add('hidden');
                }
            }
            
            function updateTagFilterDropdown() {
                const dropdown = document.getElementById('tagFilter');
                const tagsContainer = document.getElementById('availableTags');
                
                if (!dropdown || !tagsContainer) return;
                
                // Collect all unique tags
                const allTags = new Set();
                fileTags.forEach(tagSet => {
                    tagSet.forEach(tag => allTags.add(tag));
                });
                
                // Update dropdown options
                dropdown.innerHTML = '<option value="">All tagged files</option>';
                Array.from(allTags).sort().forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag;
                    option.textContent = tag;
                    dropdown.appendChild(option);
                });
                
                // Update tags container
                tagsContainer.innerHTML = '';
                Array.from(allTags).sort().forEach(tag => {
                    const tagCount = Array.from(fileTags.values()).filter(tagSet => tagSet.has(tag)).length;
                    const tagElement = document.createElement('button');
                    tagElement.className = 'px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm hover:bg-blue-200 transition-colors';
                    tagElement.textContent = `${tag} (${tagCount})`;
                    tagElement.onclick = () => {
                        dropdown.value = tag;
                        filterByTag(tag);
                    };
                    tagsContainer.appendChild(tagElement);
                });
            }
            
            function filterByTag(tag) {
                currentFilter = 'tagged';
                document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector('[data-filter="tagged"]').classList.add('active');
                
                // Set current tag filter
                window.currentTagFilter = tag;
                
                displayedItems = 0;
                loadFiles();
                
                showStatus(`Filtered by tag: ${tag}`, 'success');
            }
            
            // Enhanced Filter Function (update existing handleFilter)
            function handleFilterEnhanced(e) {
                // Update active filter button
                document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                
                currentFilter = e.target.dataset.filter;
                
                // Show/hide tag filter dropdown
                const tagDropdown = document.getElementById('tagFilterDropdown');
                if (currentFilter === 'tagged') {
                    tagDropdown.classList.remove('hidden');
                    updateTagFilterDropdown();
                } else {
                    tagDropdown.classList.add('hidden');
                    window.currentTagFilter = null;
                }
                
                displayedItems = 0;
                loadFiles();
                saveLastSession();
                saveUserPreferences();
            }
            
            // Save folder when scanning
            function saveFolderInfo(folderPath, folderName, actualSystemPath = null) {
                if (folderPath && folderName) {
                    // Try to determine the actual system path for folder-selected files
                    let systemPath = actualSystemPath;
                    
                    if (!systemPath && window.selectedFolderFiles && window.selectedFolderFiles.length > 0) {
                        const firstFile = window.selectedFolderFiles[0];
                        if (firstFile.webkitRelativePath) {
                            // For traditional folder selection, we can't get the absolute path
                            // but we can store the relative structure for better UI
                            systemPath = `[Browser Selected] ${folderName}`;
                            
                            // Try to construct a likely path based on current location
                            const currentUrl = window.location.href;
                            if (currentUrl.startsWith('file://')) {
                                const currentPath = decodeURIComponent(currentUrl.replace('file:///', '').replace(/\//g, '\\'));
                                const currentDir = currentPath.substring(0, currentPath.lastIndexOf('\\'));
                                const parentDir = currentDir.substring(0, currentDir.lastIndexOf('\\'));
                                systemPath = `${parentDir}\\${folderName}`;
                                console.log('üîç Estimated folder path:', systemPath);
                            }
                        }
                    }
                    
                    savedFolders.set(folderPath, {
                        name: folderName,
                        systemPath: systemPath,
                        lastAccessed: new Date().toISOString(),
                        fileCount: allFiles.filter(f => f.folderPath === folderPath).length,
                        method: window.selectedFolderFiles?.[0]?.isModernAPI ? 'file-system-access' : 'traditional'
                    });
                    
                    // Save last folder info for next time
                    localStorage.setItem(LAST_FOLDER_KEY, JSON.stringify({
                        path: folderPath,
                        name: folderName,
                        systemPath: systemPath,
                        timestamp: new Date().toISOString()
                    }));
                    
                    saveAllData();
                    console.log(`üíæ Saved folder: ${folderName} (${systemPath || folderPath})`);
                }
            }

            // Allow Enter key to add files
            document.addEventListener('DOMContentLoaded', function() {
                const input = document.getElementById('manualFileName');
                if (input) {
                    input.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            addManualFile();
                        }
                    });
                }
                
                // Load all saved data
                console.log('üîÑ Loading all saved data...');
                loadAllData();
                
                // Show startup info with folder library status
                setTimeout(() => {
                    const folderCount = savedFolders.size;
                    const pathCount = absoluteFilePaths.size;
                    
                    if (folderCount > 0 || pathCount > 0) {
                        let statusMsg = 'üìö Folder Library Ready! ';
                        if (folderCount > 0) statusMsg += `${folderCount} saved folders`;
                        if (folderCount > 0 && pathCount > 0) statusMsg += ', ';
                        if (pathCount > 0) statusMsg += `${pathCount} saved file paths`;
                        
                        showStatus(statusMsg, 'success');
                    } else {
                        showStatus('üìÅ Ready! Click "Add Folders" to build your folder library', 'success');
                    }
                }, 1000);
                
                // Setup folder browsing
                setupFolderBrowsing();
                
                // Setup new button event listeners
                setupEnhancedEventListeners();
                
                // Check for previous session when no files are loaded
                if (allFiles.length === 0) {
                    checkForPreviousSession();
                }
                
                // Show last folder info if available
                try {
                    const lastFolderData = localStorage.getItem(LAST_FOLDER_KEY);
                    if (lastFolderData) {
                        const parsed = JSON.parse(lastFolderData);
                        const timeSince = Math.round((Date.now() - new Date(parsed.timestamp).getTime()) / (1000 * 60 * 60)); // hours
                        const timeText = timeSince < 1 ? 'just now' : 
                                       timeSince < 24 ? `${timeSince} hours ago` : 
                                       `${Math.round(timeSince / 24)} days ago`;
                        
                        console.log(`üìÅ Last folder: ${parsed.name} (${timeText})`);
                        
                        // Show in status after a delay
                        setTimeout(() => {
                            showStatus(`üìÅ Last folder: ${parsed.name} (${timeText})`, 'success');
                        }, 3000);
                    }
                } catch (e) {
                    console.warn('Could not load last folder info:', e);
                }
            });
            
            // Setup Enhanced Event Listeners
            function setupEnhancedEventListeners() {
                // Selection mode button
                const selectionModeBtn = document.getElementById('selectionModeBtn');
                if (selectionModeBtn) {
                    selectionModeBtn.addEventListener('click', toggleSelectionMode);
                }
                
                // Open all button
                const openAllBtn = document.getElementById('openAllBtn');
                if (openAllBtn) {
                    openAllBtn.addEventListener('click', openAllSelected);
                }
                
                // Add files button
                const addFilesBtn = document.getElementById('addFilesBtn');
                if (addFilesBtn) {
                    addFilesBtn.addEventListener('click', showAddFilesDialog);
                }
                
                // Bulk action buttons
                const bulkTagBtn = document.getElementById('bulkTagBtn');
                if (bulkTagBtn) {
                    bulkTagBtn.addEventListener('click', () => performBulkAction('tag'));
                }
                
                const bulkFavoriteBtn = document.getElementById('bulkFavoriteBtn');
                if (bulkFavoriteBtn) {
                    bulkFavoriteBtn.addEventListener('click', () => performBulkAction('favorite'));
                }
                
                const bulkBookmarkBtn = document.getElementById('bulkBookmarkBtn');
                if (bulkBookmarkBtn) {
                    bulkBookmarkBtn.addEventListener('click', () => performBulkAction('bookmark'));
                }
                
                const bulkRemoveBtn = document.getElementById('bulkRemoveBtn');
                if (bulkRemoveBtn) {
                    bulkRemoveBtn.addEventListener('click', () => performBulkAction('remove'));
                }
                
                const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
                if (bulkDeleteBtn) {
                    bulkDeleteBtn.addEventListener('click', () => performBulkAction('delete'));
                }
                
                // Selection control buttons
                const selectAllBtn = document.getElementById('selectAllBtn');
                if (selectAllBtn) {
                    selectAllBtn.addEventListener('click', selectAllFiles);
                }
                
                const clearSelectionBtn = document.getElementById('clearSelectionBtn');
                if (clearSelectionBtn) {
                    clearSelectionBtn.addEventListener('click', clearSelection);
                }
                
                // Tag filter controls
                const tagFilter = document.getElementById('tagFilter');
                if (tagFilter) {
                    tagFilter.addEventListener('change', (e) => {
                        if (e.target.value) {
                            filterByTag(e.target.value);
                        } else {
                            window.currentTagFilter = null;
                            displayedItems = 0;
                            loadFiles();
                        }
                    });
                }
                
                const clearTagFilter = document.getElementById('clearTagFilter');
                if (clearTagFilter) {
                    clearTagFilter.addEventListener('click', () => {
                        document.getElementById('tagFilter').value = '';
                        window.currentTagFilter = null;
                        displayedItems = 0;
                        loadFiles();
                    });
                }
                
                // Enhanced filter buttons (replace existing)
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.removeEventListener('click', handleFilter); // Remove old handler
                    btn.addEventListener('click', handleFilterEnhanced); // Add new handler
                });
            }

            // ============================================================================
            // üöÄ PRODUCTION-READY ADVANCED FEATURES
            // ============================================================================

            // 1. ADVANCED FILE COMPARISON SYSTEM
            class FileComparison {
                static compareFiles(file1, file2) {
                    return {
                        sameSize: file1.size === file2.size,
                        sameDate: Math.abs(file1.lastModified - file2.lastModified) < 1000,
                        sameName: file1.name === file2.name,
                        similarity: this.calculateSimilarity(file1, file2)
                    };
                }
                
                static calculateSimilarity(file1, file2) {
                    const name1 = file1.displayName.toLowerCase();
                    const name2 = file2.displayName.toLowerCase();
                    const maxLen = Math.max(name1.length, name2.length);
                    if (maxLen === 0) return 1;
                    
                    let matches = 0;
                    for (let i = 0; i < Math.min(name1.length, name2.length); i++) {
                        if (name1[i] === name2[i]) matches++;
                    }
                    return matches / maxLen;
                }
                
                static findDuplicates(files) {
                    const duplicates = [];
                    for (let i = 0; i < files.length; i++) {
                        for (let j = i + 1; j < files.length; j++) {
                            const comparison = this.compareFiles(files[i], files[j]);
                            if (comparison.similarity > 0.8 || (comparison.sameSize && comparison.sameDate)) {
                                duplicates.push({file1: files[i], file2: files[j], ...comparison});
                            }
                        }
                    }
                    return duplicates;
                }
            }

            // 2. ENHANCED ANALYTICS & INSIGHTS
            class LibraryAnalytics {
                static generateReport() {
                    const report = {
                        totalFiles: allFiles.length,
                        totalSize: allFiles.reduce((sum, file) => sum + (file.size || 0), 0),
                        averageSize: 0,
                        largestFile: null,
                        smallestFile: null,
                        recentFiles: allFiles.filter(f => f.lastModified > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)),
                        filesBySize: { small: 0, medium: 0, large: 0 },
                        tagUsage: new Map(),
                        duplicates: FileComparison.findDuplicates(allFiles),
                        timestamp: new Date()
                    };
                    
                    if (report.totalFiles > 0) {
                        report.averageSize = report.totalSize / report.totalFiles;
                        report.largestFile = allFiles.reduce((max, file) => (file.size || 0) > (max?.size || 0) ? file : max, null);
                        report.smallestFile = allFiles.reduce((min, file) => (file.size || 0) < (min?.size || 0) ? file : min, null);
                    }
                    
                    // Categorize by size
                    allFiles.forEach(file => {
                        const size = file.size || 0;
                        if (size < 10000) report.filesBySize.small++;
                        else if (size < 100000) report.filesBySize.medium++;
                        else report.filesBySize.large++;
                    });
                    
                    // Tag usage statistics
                    fileTags.forEach((tags, fileName) => {
                        tags.forEach(tag => {
                            report.tagUsage.set(tag, (report.tagUsage.get(tag) || 0) + 1);
                        });
                    });
                    
                    return report;
                }
                
                static showAnalyticsDialog() {
                    const report = this.generateReport();
                    const sizeFormatted = formatFileSize(report.totalSize);
                    const avgSizeFormatted = formatFileSize(report.averageSize);
                    const topTags = Array.from(report.tagUsage.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5)
                        .map(([tag, count]) => `  ‚Ä¢ ${tag}: ${count} files`)
                        .join('\\n');
                    
                    alert(
                        `üìä LIBRARY ANALYTICS REPORT\\n` +
                        `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\\n\\n` +
                        `üìÅ Total Files: ${report.totalFiles}\\n` +
                        `üì¶ Total Size: ${sizeFormatted}\\n` +
                        `üìè Average Size: ${avgSizeFormatted}\\n` +
                        `üî• Recent Files (7 days): ${report.recentFiles.length}\\n\\n` +
                        `üìà SIZE DISTRIBUTION:\\n` +
                        `  ‚Ä¢ Small (<10KB): ${report.filesBySize.small}\\n` +
                        `  ‚Ä¢ Medium (10KB-100KB): ${report.filesBySize.medium}\\n` +
                        `  ‚Ä¢ Large (>100KB): ${report.filesBySize.large}\\n\\n` +
                        `üè∑Ô∏è TOP TAGS:\\n${topTags}\\n\\n` +
                        `üîç Potential Duplicates: ${report.duplicates.length}\\n` +
                        `üìÖ Generated: ${report.timestamp.toLocaleString()}`
                    );
                }
            }

            // 3. KEYBOARD SHORTCUTS SYSTEM
            class KeyboardShortcuts {
                static init() {
                    document.addEventListener('keydown', (e) => {
                        // Ctrl/Cmd + combinations
                        if (e.ctrlKey || e.metaKey) {
                            switch (e.key.toLowerCase()) {
                                case 'f':
                                    e.preventDefault();
                                    document.getElementById('searchInput').focus();
                                    break;
                                case 'a':
                                    if (isSelectionMode) {
                                        e.preventDefault();
                                        selectAllFiles();
                                    }
                                    break;
                                case 'r':
                                    e.preventDefault();
                                    scanDirectory();
                                    break;
                            }
                        }
                        
                        // Escape key actions
                        if (e.key === 'Escape') {
                            if (currentFilter !== 'all') {
                                filterFiles('all');
                            } else if (document.getElementById('searchInput').value) {
                                document.getElementById('searchInput').value = '';
                                handleSearch({ target: { value: '' } });
                            }
                        }
                        
                        // F2 for analytics
                        if (e.key === 'F2') {
                            e.preventDefault();
                            LibraryAnalytics.showAnalyticsDialog();
                        }
                    });
                    
                    console.log(
                        '‚å®Ô∏è KEYBOARD SHORTCUTS:\\n' +
                        '‚Ä¢ Ctrl/Cmd + F: Focus search\\n' +
                        '‚Ä¢ Ctrl/Cmd + A: Select all (in selection mode)\\n' +
                        '‚Ä¢ Ctrl/Cmd + R: Refresh/rescan\\n' +
                        '‚Ä¢ Escape: Clear filters/search\\n' +
                        '‚Ä¢ F2: Show analytics'
                    );
                }
            }

            // Initialize keyboard shortcuts
            KeyboardShortcuts.init();

            // Add analytics button to UI
            setTimeout(() => {
                const actionButtons = document.querySelector('.flex.flex-wrap.justify-center.gap-3.mb-8');
                if (actionButtons) {
                                    const analyticsBtn = document.createElement('button');
                analyticsBtn.className = 'bg-cyan-500 hover:bg-cyan-600 text-white px-4 sm:px-6 py-3 sm:py-4 rounded-xl font-semibold shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center gap-2 sm:gap-3';
                analyticsBtn.title = 'Show library analytics (F2)';
                analyticsBtn.innerHTML = '<i class="fas fa-chart-bar text-sm sm:text-lg"></i><span class="text-sm sm:text-base">Analytics</span>';
                analyticsBtn.addEventListener('click', LibraryAnalytics.showAnalyticsDialog);
                
                const pathMappingBtn = document.createElement('button');
                pathMappingBtn.className = 'bg-purple-500 hover:bg-purple-600 text-white px-4 sm:px-6 py-3 sm:py-4 rounded-xl font-semibold shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center gap-2 sm:gap-3';
                pathMappingBtn.title = 'Configure custom path mapping';
                pathMappingBtn.innerHTML = '<i class="fas fa-route text-sm sm:text-lg"></i><span class="text-sm sm:text-base">Path</span>';
                pathMappingBtn.addEventListener('click', showPathMappingDialog);
                
                actionButtons.appendChild(analyticsBtn);
                actionButtons.appendChild(pathMappingBtn);
                
                // Path mapping dialog function
                function showPathMappingDialog() {
                    const currentMapping = window.getCustomPathMapping();
                    const currentPath = currentMapping && currentMapping.enabled ? currentMapping.basePath : 'None';
                    
                    const newPath = prompt(
                        `üõ†Ô∏è CUSTOM PATH MAPPING\\n\\n` +
                        `Current: ${currentPath}\\n\\n` +
                        `Enter new base path (e.g., /D:/Design%20Dump/WealthBox)\\n` +
                        `Or leave empty to disable custom mapping:\\n\\n` +
                        `üí° This redirects file URLs to your preferred location`
                    );
                    
                    if (newPath === null) return; // User cancelled
                    
                    if (newPath.trim() === '') {
                        window.clearCustomPathMapping();
                    } else {
                        window.setCustomPathMapping(newPath.trim(), true);
                    }
                }
                }
            }, 2000);

            // ============================================================================
            // üõ†Ô∏è CUSTOM PATH MAPPING SYSTEM
            // ============================================================================
            
            // Function to set custom path mapping for URL construction
            window.setCustomPathMapping = function(basePath, enabled = true) {
                const pathConfig = {
                    enabled: enabled,
                    basePath: basePath,
                    setAt: new Date().toISOString()
                };
                
                localStorage.setItem('htmlPreviewer_customPathMapping', JSON.stringify(pathConfig));
                
                showStatus(`üîß Custom path mapping ${enabled ? 'enabled' : 'disabled'}: ${basePath}`, 'success');
                console.log('Custom path mapping set:', pathConfig);
                
                return pathConfig;
            };
            
            // Function to get current custom path mapping
            window.getCustomPathMapping = function() {
                const customPathMapping = localStorage.getItem('htmlPreviewer_customPathMapping');
                if (customPathMapping) {
                    try {
                        return JSON.parse(customPathMapping);
                    } catch (e) {
                        console.warn('Invalid custom path mapping:', e);
                        return null;
                    }
                }
                return null;
            };
            
            // Function to clear custom path mapping
            window.clearCustomPathMapping = function() {
                localStorage.removeItem('htmlPreviewer_customPathMapping');
                showStatus('üîß Custom path mapping cleared', 'success');
                console.log('Custom path mapping cleared');
            };
            
            // Auto-configure based on the specific case mentioned by user
            // If current location contains "GENERATOR Apps" and files should point to "Design Dump/WealthBox"
            const currentHref = window.location.href;
            if (currentHref.includes('GENERATOR%20Apps') || currentHref.includes('GENERATOR Apps')) {
                // Auto-configure the path mapping for the user's specific case
                const pathParts = currentHref.split('/');
                const driveIndex = pathParts.findIndex(part => part.startsWith('file:') || part.includes(':'));
                
                if (driveIndex >= 0) {
                    // Extract drive letter (e.g., "D:")
                    const drivePart = pathParts[driveIndex];
                    const driveMatch = drivePart.match(/[A-Z]:/i);
                    
                    if (driveMatch) {
                        const driveLetter = driveMatch[0];
                        const customPath = `/${driveLetter}/Design%20Dump/WealthBox`;
                        
                        // Check if custom mapping is already set
                        const existingMapping = window.getCustomPathMapping();
                        if (!existingMapping || !existingMapping.enabled) {
                            console.log('üîß Auto-configuring custom path mapping for Design Dump/WealthBox');
                            window.setCustomPathMapping(customPath, true);
                            
                            showStatus('üéØ Auto-configured path mapping for Design Dump/WealthBox', 'success');
                        }
                    }
                }
            }
            
            // Show current path mapping status
            const currentMapping = window.getCustomPathMapping();
            if (currentMapping && currentMapping.enabled) {
                console.log('üìç Custom path mapping active:', currentMapping.basePath);
                setTimeout(() => {
                    showStatus(`üìç Custom path: ${currentMapping.basePath}`, 'success');
                }, 3000);
            }
            
            console.log('üöÄ Production-ready features loaded successfully!');
        // Path Browser Function - helps fix broken file paths
        function showPathBrowser() {
            const currentPath = window.location.pathname;
            const currentDir = decodeURIComponent(currentPath.substring(0, currentPath.lastIndexOf('/') + 1));
            
            const message = `üîß PATH BROWSER - Fix Broken File Links
            
Current Location: ${currentDir}

Common paths in your GENERATOR Apps structure:
‚Ä¢ WealthBox: ../WealthBox/Website/
‚Ä¢ Diet Planner: ../DietPlanner Pro/Website/  
‚Ä¢ Trading Dashboard: ../Trading Dashboard/Website/
‚Ä¢ Focus Matrix: ../Focus Matrix/
‚Ä¢ Main Files: ../Main Files/home/

Enter the relative path where your HTML files are located:
(Example: ../WealthBox/Website/ for WealthBox files)`;

            const userPath = prompt(message, '../WealthBox/Website/');
            if (userPath && userPath.trim()) {
                setCustomBasePath(userPath.trim());
            }
        }

        function setCustomBasePath(relativePath) {
            const currentUrl = window.location.href;
            const currentDir = currentUrl.substring(0, currentUrl.lastIndexOf('/') + 1);
            
            let fullPath;
            if (relativePath.startsWith('file://')) {
                fullPath = relativePath;
            } else if (relativePath.startsWith('/')) {
                fullPath = 'file://' + relativePath;
            } else {
                // Relative path - construct from current directory
                const pathParts = currentDir.split('/');
                const relativeParts = relativePath.split('/');
                
                // Remove trailing empty parts
                while (pathParts.length > 0 && pathParts[pathParts.length - 1] === '') {
                    pathParts.pop();
                }
                
                // Process relative parts
                for (const part of relativeParts) {
                    if (part === '..') {
                        pathParts.pop();
                    } else if (part && part !== '.') {
                        pathParts.push(part);
                    }
                }
                
                fullPath = pathParts.join('/') + '/';
            }
            
            console.log(`üéØ Setting custom base path: ${fullPath}`);
            
            // Store the custom path mapping
            window.setCustomPathMapping(fullPath, true);
            showStatus(`Custom path set: ${fullPath}`, 'success');
            
            // Refresh files with new path
            refreshFiles();
        }

        // Console helper functions for debugging persistent files issue
        window.clearAllFiles = function() {
            console.log('üßπ Clearing all files...');
            preventAutoScanning = true;
            localStorage.setItem('htmlPreviewer_preventAutoScan', 'true');
            allFiles = [];
            displayedItems = 0;
            const grid = document.getElementById('filesGrid');
            if (grid) grid.innerHTML = '';
            showNoResults();
            saveLastSession(); // Save empty session
            showStatus('Files cleared - Auto-scanning disabled', 'success');
            console.log('‚úÖ All files cleared and auto-scanning disabled');
        };
        
        window.forceReload = function() {
            console.log('üîÑ Force reloading without session restoration...');
            localStorage.removeItem(LAST_SESSION_KEY);
            localStorage.removeItem('htmlPreviewer_preventAutoScan');
            window.location.reload();
        };
        
        window.enableAutoScan = function() {
            console.log('üîÑ Re-enabling auto-scanning...');
            preventAutoScanning = false;
            localStorage.removeItem('htmlPreviewer_preventAutoScan');
            showStatus('Auto-scanning re-enabled', 'success');
            console.log('‚úÖ Auto-scanning re-enabled. Use refreshFiles() to scan.');
        };
        
        window.disableAutoScan = function() {
            console.log('üö´ Disabling auto-scanning...');
            preventAutoScanning = true;
            localStorage.setItem('htmlPreviewer_preventAutoScan', 'true');
            showStatus('Auto-scanning disabled', 'success');
            console.log('‚úÖ Auto-scanning disabled.');
        };
        
        window.debugPersistence = function() {
            console.log('üîç PERSISTENCE DEBUG INFO:');
            console.log('allFiles array length:', allFiles.length);
            console.log('localStorage session:', localStorage.getItem(LAST_SESSION_KEY) ? 'EXISTS' : 'NONE');
            console.log('auto-scan disabled:', localStorage.getItem('htmlPreviewer_preventAutoScan') === 'true');
            console.log('preventAutoScanning flag:', preventAutoScanning);
            console.log('favorites count:', favorites.size);
            console.log('bookmarks count:', bookmarkedFiles.size);
            console.log('absolute paths count:', absoluteFilePaths.size);
            console.log('current filter:', currentFilter);
            console.log('current search:', currentSearch);
            
            if (allFiles.length > 0) {
                console.log('üìÅ Current files:');
                allFiles.forEach((file, index) => {
                    console.log(`  ${index + 1}. ${file.name} (${file.method || 'unknown method'})`);
                });
            }
            
            const sessionData = localStorage.getItem(LAST_SESSION_KEY);
            if (sessionData) {
                try {
                    const parsed = JSON.parse(sessionData);
                    console.log('üíæ Saved session contains:', parsed.files?.length || 0, 'files');
                } catch (e) {
                    console.log('‚ö†Ô∏è Session data is corrupted');
                }
            }
            
            return {
                allFilesCount: allFiles.length,
                hasSession: !!localStorage.getItem(LAST_SESSION_KEY),
                autoScanDisabled: localStorage.getItem('htmlPreviewer_preventAutoScan') === 'true',
                preventAutoScanningFlag: preventAutoScanning,
                favoritesCount: favorites.size,
                bookmarksCount: bookmarkedFiles.size,
                absolutePathsCount: absoluteFilePaths.size
            };
        };
        
        // Add path fixing functions
        window.fixPaths = function(basePath) {
            if (!basePath) {
                console.log('üîß PATH FIXER USAGE:');
                console.log('  fixPaths("../WealthBox/Website/") - Set WealthBox as base');
                console.log('  fixPaths("../DietPlanner Pro/Website/") - Set Diet Planner as base');
                console.log('  fixPaths("../Trading Dashboard/Website/") - Set Trading Dashboard as base');
                console.log('  fixPaths("file:///D:/YourPath/") - Set absolute path');
                console.log('');
                console.log('Current paths being used:');
                debugPersistence();
                return;
            }
            
            setCustomBasePath(basePath);
            console.log(`‚úÖ Base path set to: ${basePath}`);
            console.log('Files will now open from this location.');
        };
        
        window.showWorkingPaths = function() {
            console.log('üéØ WORKING PATH EXAMPLES:');
            console.log('Current location:', window.location.href);
            console.log('');
            console.log('Try these commands to fix broken links:');
            console.log('  fixPaths("../WealthBox/Website/")');
            console.log('  fixPaths("../DietPlanner Pro/Website/")');
            console.log('  fixPaths("../Trading Dashboard/Website/")');
            console.log('  fixPaths("../Focus Matrix/")');
            console.log('');
            console.log('Or click the purple "Fix Paths" button for a dialog.');
        };
        
        window.testPath = function(relativePath) {
            const currentUrl = window.location.href;
            const currentDir = currentUrl.substring(0, currentUrl.lastIndexOf('/') + 1);
            const testUrl = currentDir.replace(/Bulk\s*Generator[^/]*\/?$/, relativePath) + 'index.html';
            
            console.log(`üß™ Testing path: ${testUrl}`);
            
            fetch(testUrl, { method: 'HEAD' })
                .then(response => {
                    if (response.ok) {
                        console.log(`‚úÖ Path WORKS! Files found at: ${relativePath}`);
                        console.log(`Use: fixPaths("${relativePath}")`);
                    } else {
                        console.log(`‚ùå Path failed: ${response.status} ${response.statusText}`);
                    }
                })
                .catch(error => {
                    console.log(`‚ùå Path failed: ${error.message}`);
                });
        };
        
        // IMMEDIATE FIX for user's specific issue
        window.fixWealthBoxPaths = function() {
            const correctPath = 'file:///E:/Design%20Dump/WealthBox';
            console.log(`üö® FIXING WEALTHBOX PATHS TO: ${correctPath}`);
            
            // CRITICAL: Clear all saved absolute paths that have wrong paths
            console.log('üßπ Clearing all saved absolute paths...');
            localStorage.removeItem(ABSOLUTE_PATHS_KEY);
            absoluteFilePaths.clear();
            
            // CRITICAL: Clear session data that might have wrong paths
            console.log('üßπ Clearing session data...');
            localStorage.removeItem(LAST_SESSION_KEY);
            
            // Set the custom path mapping
            window.setCustomPathMapping(correctPath, true);
            showStatus(`‚úÖ WealthBox paths fixed! Files will now open from: ${correctPath}`, 'success');
            console.log('‚úÖ WealthBox paths are now fixed!');
            console.log('‚úÖ Cleared all cached wrong paths!');
            console.log('üîÑ Refreshing files...');
            refreshFiles();
        };
        
        window.showCurrentPaths = function() {
            console.log('üîç CURRENT PATH ANALYSIS:');
            console.log('Current page location:', window.location.href);
            
            const customMapping = localStorage.getItem('htmlPreviewer_customPathMapping');
            if (customMapping) {
                try {
                    const config = JSON.parse(customMapping);
                    console.log('‚úÖ Custom path mapping ACTIVE:');
                    console.log('   Enabled:', config.enabled);
                    console.log('   Base path:', config.basePath);
                } catch (e) {
                    console.log('‚ùå Custom path mapping corrupted');
                }
            } else {
                console.log('‚ùå NO custom path mapping set');
            }
            
            // Show saved absolute paths
            console.log('');
            console.log('üíæ SAVED ABSOLUTE PATHS:');
            if (absoluteFilePaths.size > 0) {
                absoluteFilePaths.forEach((path, fileName) => {
                    console.log(`   ${fileName}: ${path}`);
                });
            } else {
                console.log('   None saved');
            }
            
            console.log('');
            console.log('üö® QUICK FIX: Run fixWealthBoxPaths() to fix immediately');
        };
        
        // NUCLEAR PATH RESET - Force correct paths for everything
        window.nuclearPathFix = function() {
            console.log('üí• NUCLEAR PATH FIX - Forcing correct WealthBox paths');
            
            // Clear EVERYTHING that could interfere
            localStorage.removeItem(ABSOLUTE_PATHS_KEY);
            localStorage.removeItem(LAST_SESSION_KEY);
            localStorage.removeItem('htmlPreviewer_customPathMapping');
            absoluteFilePaths.clear();
            allFiles = [];
            
            // Set correct path
            const correctPath = 'file:///E:/Design%20Dump/WealthBox';
            window.setCustomPathMapping(correctPath, true);
            
            // Force immediate path check
            console.log('üéØ CURRENT CUSTOM PATH MAPPING:');
            const mapping = localStorage.getItem('htmlPreviewer_customPathMapping');
            console.log('Raw storage:', mapping);
            
            if (mapping) {
                try {
                    const config = JSON.parse(mapping);
                    console.log('Parsed config:', config);
                } catch (e) {
                    console.log('Parse error:', e);
                }
            }
            
            showStatus('üí• Nuclear path fix applied - WealthBox paths forced', 'success');
            console.log('üí• All interfering data cleared, correct path set');
            
            // Don't auto-refresh, let user control it
            console.log('üîÑ Run refreshFiles() manually to test');
        };

        // Make debugging functions globally available
        console.log('üéØ Universal HTML Previewer loaded!');
        console.log('üìù Console commands available:');
        console.log('  ‚Ä¢ clearAllFiles() - Remove all files + disable auto-scan');
        console.log('  ‚Ä¢ nuclearReset() - Complete data wipe (DANGEROUS!)');
        console.log('  ‚Ä¢ forceReload() - Hard reload without session restoration');
        console.log('  ‚Ä¢ enableAutoScan() - Re-enable automatic file discovery');
        console.log('  ‚Ä¢ disableAutoScan() - Disable automatic file discovery');
        console.log('  ‚Ä¢ debugPersistence() - Check what data is stored');
        console.log('  ‚Ä¢ resetAllPreviews() - Reset everything cleanly');
        console.log('  ‚Ä¢ clearStoredData() - Clear just storage, keep current files');
        console.log('');
        console.log('üîß PATH FIXING COMMANDS:');
        console.log('  ‚Ä¢ fixWealthBoxPaths() - INSTANT FIX for WealthBox paths');
        console.log('  ‚Ä¢ nuclearPathFix() - NUCLEAR OPTION - Force correct paths');
        console.log('  ‚Ä¢ showCurrentPaths() - Show current path configuration');
        console.log('  ‚Ä¢ fixPaths() - Show path fixing help');
        console.log('  ‚Ä¢ showWorkingPaths() - Show common working paths');
        console.log('  ‚Ä¢ testPath("../WealthBox/Website/") - Test if path works');
        console.log('  ‚Ä¢ showPathBrowser() - Open path browser dialog');
        console.log('');
        console.log('üö® STILL BROKEN? Type nuclearPathFix() then refreshFiles()!');
        
    </script>
</body>
</html>